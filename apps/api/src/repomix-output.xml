This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
api/controllers/academic_year_controller.py
api/controllers/ai_controller.py
api/controllers/assessment_clo_controller.py
api/controllers/assessment_component_controller.py
api/controllers/assessment_scheme_controller.py
api/controllers/auth_controller.py
api/controllers/clo_plo_mapping_controller.py
api/controllers/dashboard_controller.py
api/controllers/department_controller.py
api/controllers/faculty_controller.py
api/controllers/file_controller.py
api/controllers/notification_controller.py
api/controllers/program_controller.py
api/controllers/program_outcome_controller.py
api/controllers/public_controller.py
api/controllers/role_controller.py
api/controllers/rubric_controller.py
api/controllers/student_controller.py
api/controllers/subject_controller.py
api/controllers/subject_relationship_controller.py
api/controllers/syllabus_clo_controller.py
api/controllers/syllabus_comment_controller.py
api/controllers/syllabus_controller.py
api/controllers/syllabus_material_controller.py
api/controllers/system_setting_controller.py
api/controllers/teaching_plan_controller.py
api/controllers/user_controller.py
api/middleware.py
api/requests.py
api/responses.py
api/routes.py
api/schemas/...  # Marshmallow schemas
api/schemas/academic_year_schema.py
api/schemas/assessment_clo_mapping_schema.py
api/schemas/assessment_component_schema.py
api/schemas/assessment_scheme_schema.py
api/schemas/base_schema.py
api/schemas/clo_plo_mapping_schema.py
api/schemas/department_schema.py
api/schemas/faculty_schema.py
api/schemas/file_schema.py
api/schemas/notification_schema.py
api/schemas/program_outcome_schema.py
api/schemas/program_schema.py
api/schemas/role_schema.py
api/schemas/rubric_schema.py
api/schemas/student_schema.py
api/schemas/subject_relationship_schema.py
api/schemas/subject_schema.py
api/schemas/syllabus_clo_schema.py
api/schemas/syllabus_comment_schema.py
api/schemas/syllabus_detail_schema.py
api/schemas/syllabus_material_schema.py
api/schemas/syllabus_schema.py
api/schemas/system_setting_schema.py
api/schemas/teaching_plan_schema.py
api/schemas/user_schema.py
api/schemas/user.py
api/schemas/workflow_log_schema.py
api/swagger.py
app_logging.py
app.py
config.py
cors.py
create_app.py
default.db
dependency_container.py
domain/constants.py
domain/exceptions.py
domain/models/...  # Business logic models
domain/models/user.py
error_handler.py
infrastructure/databases/__init__.py
infrastructure/databases/base.py
infrastructure/databases/mssql.py
infrastructure/databases/mysql.py
infrastructure/models/__init__.py
infrastructure/models/academic_year_model.py
infrastructure/models/ai_auditlog_model.py
infrastructure/models/assessment_clo_model.py
infrastructure/models/assessment_component_model.py
infrastructure/models/assessment_scheme_model.py
infrastructure/models/clo_plo_mapping_model.py
infrastructure/models/department_model.py
infrastructure/models/faculty_model.py
infrastructure/models/file_model.py
infrastructure/models/notification_model.py
infrastructure/models/notification_template_model.py
infrastructure/models/program_model.py
infrastructure/models/program_outcome_model.py
infrastructure/models/role_model.py
infrastructure/models/rubric_model.py
infrastructure/models/student_report_model.py
infrastructure/models/student_subscription_model.py
infrastructure/models/subject_model.py
infrastructure/models/subject_relationship_model.py
infrastructure/models/syllabus_clo_model.py
infrastructure/models/syllabus_comment_model.py
infrastructure/models/syllabus_current_workflow.py
infrastructure/models/syllabus_material_model.py
infrastructure/models/syllabus_model.py
infrastructure/models/system_auditlog_model.py
infrastructure/models/system_setting_model.py
infrastructure/models/teaching_plan_model.py
infrastructure/models/user_model.py
infrastructure/models/user_role_model.py
infrastructure/models/workflow_log_model.py
infrastructure/models/workflow_state_model.py
infrastructure/models/workflow_transition_model.py
infrastructure/repositories/academic_year_repository.py
infrastructure/repositories/ai_auditlog_repository.py
infrastructure/repositories/assessment_clo_repository.py
infrastructure/repositories/assessment_component_repository.py
infrastructure/repositories/assessment_scheme_repository.py
infrastructure/repositories/clo_plo_mapping_repository.py
infrastructure/repositories/department_repository.py
infrastructure/repositories/faculty_repository.py
infrastructure/repositories/file_repository.py
infrastructure/repositories/notification_repository.py
infrastructure/repositories/program_outcome_repository.py
infrastructure/repositories/program_repository.py
infrastructure/repositories/role_repository.py
infrastructure/repositories/rubric_repository.py
infrastructure/repositories/student_report_repository.py
infrastructure/repositories/student_subscription_repository.py
infrastructure/repositories/subject_relationship_repository.py
infrastructure/repositories/subject_repository.py
infrastructure/repositories/syllabus_clo_repository.py
infrastructure/repositories/syllabus_comment_repository.py
infrastructure/repositories/syllabus_material_repository.py
infrastructure/repositories/syllabus_repository.py
infrastructure/repositories/system_setting_repository.py
infrastructure/repositories/teaching_plan_repository.py
infrastructure/repositories/user_repository.py
infrastructure/repositories/workflow_log_repository.py
infrastructure/services/...  # Services that use third party libraries or services (e.g. email service)
migrations
requirements_additional.txt
requirements.txt
scripts/import_check.py
scripts/run_postgres.sh
scripts/seed_users.py
SDM-workspace.code-workspace
services/...  # Services for interacting with the domain (business logic)
services/academic_year_service.py
services/ai_service.py
services/assessment_clo_service.py
services/assessment_component_service.py
services/assessment_scheme_service.py
services/clo_plo_mapping_service.py
services/department_service.py
services/faculty_service.py
services/file_service.py
services/notification_service.py
services/program_outcome_service.py
services/program_service.py
services/role_service.py
services/rubric_service.py
services/student_service.py
services/subject_relationship_service.py
services/subject_service.py
services/syllabus_clo_service.py
services/syllabus_comment_service.py
services/syllabus_material_service.py
services/syllabus_service.py
services/system_setting_service.py
services/teaching_plan_service.py
services/user_service.py
swagger_config.json
tests/test_file_service.py
tests/test_program_outcome_service.py
tests/test_smoke_imports.py
tests/test_syllabus_service.py
utils/caching.py
utils/logging_config.py
utils/pagination.py
utils/performance.py
verify_fixes.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="api/controllers/academic_year_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.academic_year_service import AcademicYearService
from api.schemas.academic_year_schema import AcademicYearSchema

academic_year_bp = Blueprint('academic_year', __name__, url_prefix='/academic-years')

schema = AcademicYearSchema()

@academic_year_bp.route('/', methods=['GET', 'OPTIONS'], strict_slashes=False)
@inject
def list_academic_years(academic_year_service: AcademicYearService = Provide[Container.academic_year_service]):
    """Get all academic years
    ---
    get:
      summary: Get all academic years
      tags:
        - AcademicYears
      responses:
        200:
          description: List of academic years
    """
    items = academic_year_service.list_academic_years()
    return jsonify(schema.dump(items, many=True)), 200

@academic_year_bp.route('/', methods=['POST', 'OPTIONS'], strict_slashes=False)
@inject
def create_academic_year(academic_year_service: AcademicYearService = Provide[Container.academic_year_service]):
    """Create a new academic year
    ---
    post:
      summary: Create an academic year
      tags:
        - AcademicYears
      requestBody:
        required: true
      responses:
        201:
          description: Created
        400:
          description: Invalid input
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    ay = academic_year_service.create_academic_year(data)
    return jsonify(schema.dump(ay)), 201

@academic_year_bp.route('/<int:id>', methods=['PUT', 'OPTIONS'], strict_slashes=False)
@inject
def update_academic_year(id: int, academic_year_service: AcademicYearService = Provide[Container.academic_year_service]):
    data = request.get_json() or {}
    errors = schema.validate(data, partial=True)
    if errors:
        return jsonify(errors), 400
    ay = academic_year_service.update_academic_year(id, data)
    if not ay:
        return jsonify({'message': 'AcademicYear not found'}), 404
    return jsonify(schema.dump(ay)), 200

@academic_year_bp.route('/<int:id>', methods=['DELETE', 'OPTIONS'], strict_slashes=False)
@inject
def delete_academic_year(id: int, academic_year_service: AcademicYearService = Provide[Container.academic_year_service]):
    ok = academic_year_service.delete_academic_year(id)
    if not ok:
        return jsonify({'message': 'AcademicYear not found'}), 404
    return '', 204
</file>

<file path="api/controllers/ai_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.ai_service import AiService
import logging

logger = logging.getLogger(__name__)
ai_bp = Blueprint('ai', __name__, url_prefix='/ai')

@ai_bp.route('/generate', methods=['POST', 'OPTIONS'], strict_slashes=False)
@inject
def generate(ai_service: AiService = Provide[Container.ai_service]):
    """Generate syllabus using AI with comprehensive error handling."""
    try:
        data = request.get_json() or {}
        subject_name = data.get('subject_name', '').strip()
        
        if not subject_name:
            return jsonify({'message': 'subject_name is required and cannot be empty'}), 400

        logger.info(f"AI generation request for: {subject_name}")
        
        # Call service with error handling
        try:
            res = ai_service.generate(subject_name)
        except Exception as e:
            logger.error(f"AI service error: {e}", exc_info=True)
            return jsonify({'message': f'AI service error: {str(e)}'}), 500
        
        # Validate response type
        if not isinstance(res, dict):
            logger.error(f"Invalid response type from AI service: {type(res)}")
            return jsonify({'message': 'Invalid response from AI service'}), 500
        
        # Handle error response from AI service
        if res.get('error'):
            error_msg = res.get('error')
            logger.warning(f"AI generation error: {error_msg}")
            return jsonify({'message': error_msg}), 400
        
        logger.info(f"AI generation successful for: {subject_name}")
        return jsonify(res), 200
    
    except ValueError as e:
        logger.error(f"Validation error: {e}")
        return jsonify({'message': str(e)}), 422
    except Exception as e:
        logger.error(f"Unexpected error in /ai/generate: {e}", exc_info=True)
        return jsonify({'message': 'Unexpected error occurred'}), 500
</file>

<file path="api/controllers/assessment_clo_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.assessment_clo_service import AssessmentCloService
from api.schemas.assessment_clo_mapping_schema import AssessmentCloMappingSchema

assessment_clo_bp = Blueprint('assessment_clo_map', __name__, url_prefix='/assessment-clos')

schema = AssessmentCloMappingSchema()

@assessment_clo_bp.route('/component/<int:component_id>', methods=['GET'])
@inject
def list_clos(component_id: int, service: AssessmentCloService = Provide[Container.assessment_clo_service]):
    """
    List CLOs mapped to a component
    ---
    tags:
      - Assessments
    parameters:
      - name: component_id
        in: path
        required: true
        schema:
          type: integer
    responses:
      200:
        description: List of CLOs (id, code, description)
        content:
          application/json:
            schema:
              type: array
              items:
                type: object
                properties:
                  id:
                    type: integer
                  code:
                    type: string
                  description:
                    type: string
    """
    items = service.get_clos_for_component(component_id)
    return jsonify([{'id': c.id, 'code': c.code, 'description': c.description} for c in items]), 200

@assessment_clo_bp.route('/', methods=['POST', 'OPTIONS'], strict_slashes=False)
@inject
def add_mapping(service: AssessmentCloService = Provide[Container.assessment_clo_service]):
    """
    Map a CLO to an assessment component
    ---
    tags:
      - Assessments
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/AssessmentCloMapping'
    responses:
      201:
        description: Mapping created
      400:
        description: Validation or integrity error
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    try:
        mapping = service.add_mapping(data['assessment_component_id'], data['syllabus_clo_id'])
    except Exception as e:
        return jsonify({'error': str(e)}), 400
    return jsonify({'assessment_component_id': mapping.assessment_component_id, 'syllabus_clo_id': mapping.syllabus_clo_id}), 201

@assessment_clo_bp.route('/', methods=['DELETE', 'OPTIONS'], strict_slashes=False)
@inject
def remove_mapping(service: AssessmentCloService = Provide[Container.assessment_clo_service]):
    """
    Remove a mapping between component and CLO
    ---
    tags:
      - Assessments
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/AssessmentCloMapping'
    responses:
      204:
        description: Mapping removed
      400:
        description: Bad request
      404:
        description: Mapping not found
    """
    data = request.get_json() or {}
    if not data:
        return jsonify({'error': 'Provide JSON body with assessment_component_id and syllabus_clo_id'}), 400
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    ok = service.remove_mapping(data['assessment_component_id'], data['syllabus_clo_id'])
    if not ok:
        return jsonify({'message': 'Mapping not found'}), 404
    return '', 204
</file>

<file path="api/controllers/assessment_component_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.assessment_component_service import AssessmentComponentService
from api.schemas.assessment_component_schema import AssessmentComponentSchema

assessment_component_bp = Blueprint('assessment_component', __name__, url_prefix='/assessment-components')

schema = AssessmentComponentSchema()

@assessment_component_bp.route('/', methods=['POST', 'OPTIONS'], strict_slashes=False)
@inject
def create_component(service: AssessmentComponentService = Provide[Container.assessment_component_service]):
    """
    Create an assessment component
    ---
    tags:
      - Assessments
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/AssessmentComponent'
    responses:
      201:
        description: Component created
      400:
        description: Validation or creation error
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    try:
        item = service.create_component(data)
    except Exception as e:
        return jsonify({'error': str(e)}), 400
    return jsonify(schema.dump(item)), 201

@assessment_component_bp.route('/<int:id>', methods=['PUT', 'OPTIONS'], strict_slashes=False)
@inject
def update_component(id: int, service: AssessmentComponentService = Provide[Container.assessment_component_service]):
    """
    Update an assessment component
    ---
    tags:
      - Assessments
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: integer
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/AssessmentComponent'
    responses:
      200:
        description: Component updated
      400:
        description: Validation error
      404:
        description: Component not found
    """
    data = request.get_json() or {}
    errors = schema.validate(data, partial=True)
    if errors:
        return jsonify(errors), 400
    item = service.update_component(id, data)
    if not item:
        return jsonify({'message': 'Component not found'}), 404
    return jsonify(schema.dump(item)), 200

@assessment_component_bp.route('/<int:id>', methods=['DELETE', 'OPTIONS'], strict_slashes=False)
@inject
def delete_component(id: int, service: AssessmentComponentService = Provide[Container.assessment_component_service]):
    """
    Delete an assessment component
    ---
    tags:
      - Assessments
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: integer
    responses:
      204:
        description: Deleted
      404:
        description: Component not found
    """
    ok = service.delete_component(id)
    if not ok:
        return jsonify({'message': 'Component not found'}), 404
    return '', 204
</file>

<file path="api/controllers/assessment_scheme_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.assessment_scheme_service import AssessmentSchemeService
from api.schemas.assessment_scheme_schema import AssessmentSchemeSchema

assessment_scheme_bp = Blueprint('assessment_scheme', __name__, url_prefix='/assessment-schemes')

schema = AssessmentSchemeSchema()

@assessment_scheme_bp.route('/syllabus/<int:syllabus_id>', methods=['GET'])
@inject
def list_schemes(syllabus_id: int, service: AssessmentSchemeService = Provide[Container.assessment_scheme_service]):
    """
    List assessment schemes for a syllabus
    ---
    tags:
      - Assessments
    parameters:
      - name: syllabus_id
        in: path
        required: true
        schema:
          type: integer
    responses:
      200:
        description: List of assessment schemes
        content:
          application/json:
            schema:
              type: array
              items:
                $ref: '#/components/schemas/AssessmentScheme'
    """
    items = service.list_schemes_for_syllabus(syllabus_id)
    return jsonify(schema.dump(items, many=True)), 200

@assessment_scheme_bp.route('/', methods=['POST', 'OPTIONS'], strict_slashes=False)
@inject
def create_scheme(service: AssessmentSchemeService = Provide[Container.assessment_scheme_service]):
    """
    Create an assessment scheme
    ---
    tags:
      - Assessments
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/AssessmentScheme'
    responses:
      201:
        description: Scheme created
      400:
        description: Validation or creation error
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    try:
        item = service.create_scheme(data)
    except Exception as e:
        return jsonify({'error': str(e)}), 400
    return jsonify(schema.dump(item)), 201

@assessment_scheme_bp.route('/<int:id>', methods=['PUT', 'OPTIONS'], strict_slashes=False)
@inject
def update_scheme(id: int, service: AssessmentSchemeService = Provide[Container.assessment_scheme_service]):
    """
    Update an assessment scheme
    ---
    tags:
      - Assessments
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: integer
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/AssessmentScheme'
    responses:
      200:
        description: Scheme updated
      400:
        description: Validation error
      404:
        description: Scheme not found
    """
    data = request.get_json() or {}
    errors = schema.validate(data, partial=True)
    if errors:
        return jsonify(errors), 400
    item = service.update_scheme(id, data)
    if not item:
        return jsonify({'message': 'Scheme not found'}), 404
    return jsonify(schema.dump(item)), 200

@assessment_scheme_bp.route('/<int:id>', methods=['DELETE', 'OPTIONS'], strict_slashes=False)
@inject
def delete_scheme(id: int, service: AssessmentSchemeService = Provide[Container.assessment_scheme_service]):
    """
    Delete an assessment scheme
    ---
    tags:
      - Assessments
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: integer
    responses:
      204:
        description: Deleted
      404:
        description: Scheme not found
    """
    ok = service.delete_scheme(id)
    if not ok:
        return jsonify({'message': 'Scheme not found'}), 404
    return '', 204
</file>

<file path="api/controllers/auth_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.user_service import UserService
from werkzeug.security import check_password_hash
import jwt
from datetime import datetime, timedelta
from config import Config

auth_bp = Blueprint('auth', __name__, url_prefix='/auth')

@auth_bp.route('/login', methods=['POST', 'OPTIONS'], strict_slashes=False)
@inject
def login(user_service: UserService = Provide[Container.user_service]):
    """
    Login and obtain a token
    ---
    tags:
      - Auth
    requestBody:
      required: true
      content:
        application/json:
          schema:
            type: object
            properties:
              username:
                type: string
              password:
                type: string
            required:
              - username
              - password
    responses:
      200:
        description: Login successful, returns token and user information
      400:
        description: Missing username or password
      401:
        description: Invalid credentials
    """
    if request.method == 'OPTIONS':
      # Fast path for CORS preflight
      return jsonify({'message': 'CORS preflight OK'}), 200

    data = request.get_json() or {}
    username = data.get('username')
    password = data.get('password')
    if not username or not password:
        return jsonify({'message': 'username and password are required'}), 400
    user = user_service.get_by_username(username)
    if not user:
        return jsonify({'message': 'Invalid credentials'}), 401
    if not check_password_hash(user.password_hash, password):
        return jsonify({'message': 'Invalid credentials'}), 401

    # Get role name if available
    role_name = None
    try:
        if user.roles and len(user.roles) > 0 and getattr(user.roles[0], 'role', None):
            role_name = user.roles[0].role.name
    except Exception:
        role_name = None

    # Generate real JWT token
    payload = {
        'user_id': user.id,
        'username': user.username,
        'role': role_name,
        'exp': datetime.utcnow() + timedelta(hours=24),  # Token expires in 24 hours
        'iat': datetime.utcnow()
    }
    
    token = jwt.encode(payload, Config.SECRET_KEY, algorithm='HS256')
    
    return jsonify({
        'access_token': token,
        'token': token,  # Keep for backward compatibility
        'user_id': user.id, 
        'role': role_name
    }), 200
</file>

<file path="api/controllers/clo_plo_mapping_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.clo_plo_mapping_service import CloPloMappingService
from api.schemas.clo_plo_mapping_schema import CloPloMappingSchema

clo_plo_mapping_bp = Blueprint('clo_plo_mapping', __name__, url_prefix='/clo-plo-mappings')
schema = CloPloMappingSchema()

@clo_plo_mapping_bp.route('/', methods=['POST', 'OPTIONS'], strict_slashes=False)
@inject
def create_mapping(service: CloPloMappingService = Provide[Container.clo_plo_mapping_service]):
    """
    Create CLO-PLO Mapping
    ---
    tags:
      - Mappings (CLO-PLO)
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/CloPloMapping'
    responses:
      201: {description: Created}
      400: {description: Error}
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    try:
        item = service.create_mapping(data)
        return jsonify(schema.dump(item)), 201
    except ValueError as e:
        return jsonify({'error': str(e)}), 400

@clo_plo_mapping_bp.route('/<int:id>', methods=['DELETE', 'OPTIONS'], strict_slashes=False)
@inject
def delete_mapping(id: int, service: CloPloMappingService = Provide[Container.clo_plo_mapping_service]):
    """
    Delete CLO-PLO Mapping
    ---
    tags:
      - Mappings (CLO-PLO)
    parameters:
      - name: id
        in: path
        required: true
        schema: {type: integer}
    responses:
      204: {description: Deleted}
    """
    ok = service.delete_mapping(id)
    if not ok:
        return jsonify({'message': 'Mapping not found'}), 404
    return '', 204
</file>

<file path="api/controllers/dashboard_controller.py">
from flask import Blueprint, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.syllabus_service import SyllabusService
from services.user_service import UserService

dashboard_bp = Blueprint('dashboard', __name__, url_prefix='/stats')

@dashboard_bp.route('/', methods=['GET', 'OPTIONS'], strict_slashes=False)
@inject
def get_stats(syllabus_service: SyllabusService = Provide[Container.syllabus_service], user_service: UserService = Provide[Container.user_service]):
    syllabuses = syllabus_service.list_syllabuses() or []
    users = user_service.list_users() or []

    total_syllabuses = len(syllabuses)
    total_users = len(users)

    # Group by status
    stats_by_status = {
        'Approved': 0,
        'Pending': 0,
        'Draft': 0,
        'Returned': 0
    }
    for s in syllabuses:
        status = getattr(s, 'status', None) or getattr(s, 'state', None) or 'Draft'
        # Normalize
        if status.upper() in ('APPROVED',):
            stats_by_status['Approved'] += 1
        elif 'PENDING' in status.upper():
            stats_by_status['Pending'] += 1
        elif status.upper() in ('RETURNED', 'REJECTED'):
            stats_by_status['Returned'] += 1
        else:
            stats_by_status['Draft'] += 1

    # Convert to array format for frontend charts
    status_breakdown = [
        {"name": "Đã duyệt", "value": stats_by_status['Approved'], "fill": "#10b981"},
        {"name": "Chờ duyệt", "value": stats_by_status['Pending'], "fill": "#f59e0b"},
        {"name": "Nháp", "value": stats_by_status['Draft'], "fill": "#6b7280"},
        {"name": "Trả lại", "value": stats_by_status['Returned'], "fill": "#ef4444"}
    ]

    return jsonify({
        'total_syllabuses': total_syllabuses,
        'total_syllabus': total_syllabuses,  # Alias for frontend
        'total_users': total_users,
        'by_status': stats_by_status,  # Keep for backward compatibility
        'status_breakdown': status_breakdown  # Array format for charts
    }), 200
</file>

<file path="api/controllers/department_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.department_service import DepartmentService
from api.schemas.department_schema import DepartmentSchema

department_bp = Blueprint('department', __name__, url_prefix='/departments')

schema = DepartmentSchema()

@department_bp.route('/', methods=['GET', 'OPTIONS'], strict_slashes=False)
@inject
def list_departments(department_service: DepartmentService = Provide[Container.department_service]):
    """Get all departments
    ---
    get:
      summary: Get all departments
      tags:
        - Departments
      responses:
        200:
          description: List of departments
    """
    departments = department_service.list_departments()
    return jsonify(schema.dump(departments, many=True)), 200

@department_bp.route('/<int:id>', methods=['GET', 'OPTIONS'], strict_slashes=False)
@inject
def get_department(id: int, department_service: DepartmentService = Provide[Container.department_service]):
    """Get department by id
    ---
    get:
      summary: Get department by ID
      tags:
        - Departments
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        200:
          description: Department object
        404:
          description: Not found
    """
    department = department_service.get_department(id)
    if not department:
        return jsonify({'message': 'Department not found'}), 404
    return jsonify(schema.dump(department)), 200

@department_bp.route('/', methods=['POST', 'OPTIONS'], strict_slashes=False)
@inject
def create_department(department_service: DepartmentService = Provide[Container.department_service]):
    """Create a new department
    ---
    post:
      summary: Create a new department
      tags:
        - Departments
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Department'
      responses:
        201:
          description: Department created
        400:
          description: Invalid input
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    department = department_service.create_department(data)
    return jsonify(schema.dump(department)), 201

@department_bp.route('/<int:id>', methods=['PUT', 'OPTIONS'], strict_slashes=False)
@inject
def update_department(id: int, department_service: DepartmentService = Provide[Container.department_service]):
    """Update an existing department
    ---
    put:
      summary: Update department
      tags:
        - Departments
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Department'
      responses:
        200:
          description: Department updated
        400:
          description: Invalid input
        404:
          description: Department not found
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    department = department_service.update_department(id, data)
    if not department:
        return jsonify({'message': 'Department not found'}), 404
    return jsonify(schema.dump(department)), 200

@department_bp.route('/<int:id>', methods=['DELETE', 'OPTIONS'], strict_slashes=False)
@inject
def delete_department(id: int, department_service: DepartmentService = Provide[Container.department_service]):
    """Delete department
    ---
    delete:
      summary: Delete department
      tags:
        - Departments
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        204:
          description: Deleted
        404:
          description: Department not found
    """
    ok = department_service.delete_department(id)
    if not ok:
        return jsonify({'message': 'Department not found'}), 404
    return '', 204
</file>

<file path="api/controllers/faculty_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.faculty_service import FacultyService
from api.schemas.faculty_schema import FacultySchema

faculty_bp = Blueprint('faculty', __name__, url_prefix='/faculties')

schema = FacultySchema()

@faculty_bp.route('/', methods=['GET', 'OPTIONS'], strict_slashes=False)
@inject
def list_faculties(faculty_service: FacultyService = Provide[Container.faculty_service]):
    """Get all faculties
    ---
    get:
      summary: Get all faculties
      tags:
        - Faculties
      responses:
        200:
          description: List of faculties
    """
    faculties = faculty_service.list_faculties()
    return jsonify(schema.dump(faculties, many=True)), 200

@faculty_bp.route('/<int:id>', methods=['GET', 'OPTIONS'], strict_slashes=False)
@inject
def get_faculty(id: int, faculty_service: FacultyService = Provide[Container.faculty_service]):
    """Get faculty by id
    ---
    get:
      summary: Get faculty by ID
      tags:
        - Faculties
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        200:
          description: Faculty object
        404:
          description: Not found
    """
    faculty = faculty_service.get_faculty(id)
    if not faculty:
        return jsonify({'message': 'Faculty not found'}), 404
    return jsonify(schema.dump(faculty)), 200

@faculty_bp.route('/', methods=['POST', 'OPTIONS'], strict_slashes=False)
@inject
def create_faculty(faculty_service: FacultyService = Provide[Container.faculty_service]):
    """Create a new faculty
    ---
    post:
      summary: Create a new faculty
      tags:
        - Faculties
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Faculty'
      responses:
        201:
          description: Faculty created
        400:
          description: Invalid input
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    faculty = faculty_service.create_faculty(data)
    return jsonify(schema.dump(faculty)), 201

@faculty_bp.route('/<int:id>', methods=['PUT', 'OPTIONS'], strict_slashes=False)
@inject
def update_faculty(id: int, faculty_service: FacultyService = Provide[Container.faculty_service]):
    """Update an existing faculty
    ---
    put:
      summary: Update faculty
      tags:
        - Faculties
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Faculty'
      responses:
        200:
          description: Faculty updated
        400:
          description: Invalid input
        404:
          description: Faculty not found
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    faculty = faculty_service.update_faculty(id, data)
    if not faculty:
        return jsonify({'message': 'Faculty not found'}), 404
    return jsonify(schema.dump(faculty)), 200

@faculty_bp.route('/<int:id>', methods=['DELETE', 'OPTIONS'], strict_slashes=False)
@inject
def delete_faculty(id: int, faculty_service: FacultyService = Provide[Container.faculty_service]):
    """Delete faculty
    ---
    delete:
      summary: Delete faculty
      tags:
        - Faculties
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        204:
          description: Deleted
        404:
          description: Faculty not found
    """
    ok = faculty_service.delete_faculty(id)
    if not ok:
        return jsonify({'message': 'Faculty not found'}), 404
    return '', 204
</file>

<file path="api/controllers/file_controller.py">
from flask import Blueprint, request, jsonify, send_file
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.file_service import FileService
from api.schemas.file_schema import FileSchema
import os

file_bp = Blueprint('file', __name__, url_prefix='/files')
schema = FileSchema()

@file_bp.route('/upload', methods=['POST', 'OPTIONS'], strict_slashes=False)
@inject
def upload_file(service: FileService = Provide[Container.file_service]):
    if 'file' not in request.files:
        return jsonify({'error': 'No file part'}), 400
    file = request.files['file']
    # Demo: assume user_id=1 if no auth (In production, get from token)
    user_id = request.form.get('user_id', 1) 
    try:
        record = service.upload_file(file, int(user_id))
        return jsonify(schema.dump(record)), 201
    except ValueError as e:
        return jsonify({'error': str(e)}), 400

@file_bp.route('/<int:id>', methods=['GET'])
@inject
def download_file(id: int, service: FileService = Provide[Container.file_service]):
    record = service.get_file(id)
    if not record:
        return jsonify({'message': 'File not found'}), 404
    try:
        return send_file(os.path.abspath(record.file_path), as_attachment=True, download_name=record.file_name)
    except Exception:
        return jsonify({'message': 'File not found on disk'}), 404
</file>

<file path="api/controllers/notification_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.notification_service import NotificationService
from api.schemas.notification_schema import NotificationSchema
from api.middleware import token_required

notification_bp = Blueprint('notification', __name__, url_prefix='/notifications')
schema = NotificationSchema()

@notification_bp.route('/', methods=['GET', 'OPTIONS'], strict_slashes=False)
@inject
@token_required
def get_my_notifications(service: NotificationService = Provide[Container.notification_service]):
    """
    Get current user's notifications
    ---
    tags:
      - Notifications
    parameters:
      - name: unread
        in: query
        type: boolean
        description: Filter by unread only
    responses:
      200:
        description: List of notifications
    """
    from flask import g
    user_id = getattr(g, 'user_id', None)
    if not user_id:
         return jsonify({'message': 'User context missing'}), 401
    unread = request.args.get('unread', 'false').lower() == 'true'
    items = service.get_user_notifications(user_id, unread_only=unread)
    return jsonify(schema.dump(items, many=True)), 200

@notification_bp.route('/<int:id>/read', methods=['PUT', 'OPTIONS'], strict_slashes=False)
@inject
@token_required
def mark_read(id: int, service: NotificationService = Provide[Container.notification_service]):
    """
    Mark a notification as read
    ---
    tags:
      - Notifications
    parameters:
      - name: id
        in: path
        required: true
        schema: {type: integer}
    responses:
      200:
        description: Marked as read
    """
    ok = service.mark_read(id)
    if not ok:
        return jsonify({'message': 'Notification not found'}), 404
    return jsonify({'message': 'Marked as read'}), 200
</file>

<file path="api/controllers/program_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.program_service import ProgramService
from api.schemas.program_schema import ProgramSchema

program_bp = Blueprint('program', __name__, url_prefix='/programs')

schema = ProgramSchema()

@program_bp.route('/', methods=['GET', 'OPTIONS'], strict_slashes=False)
@inject
def list_programs(program_service: ProgramService = Provide[Container.program_service]):
    """Get all programs
    ---
    get:
      summary: Get all programs
      tags:
        - Programs
      responses:
        200:
          description: List of programs
    """
    items = program_service.list_programs()
    return jsonify(schema.dump(items, many=True)), 200

@program_bp.route('/', methods=['POST', 'OPTIONS'], strict_slashes=False)
@inject
def create_program(program_service: ProgramService = Provide[Container.program_service]):
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    p = program_service.create_program(data)
    return jsonify(schema.dump(p)), 201

@program_bp.route('/<int:id>', methods=['PUT', 'OPTIONS'], strict_slashes=False)
@inject
def update_program(id: int, program_service: ProgramService = Provide[Container.program_service]):
    data = request.get_json() or {}
    errors = schema.validate(data, partial=True)
    if errors:
        return jsonify(errors), 400
    p = program_service.update_program(id, data)
    if not p:
        return jsonify({'message': 'Program not found'}), 404
    return jsonify(schema.dump(p)), 200

@program_bp.route('/<int:id>', methods=['DELETE', 'OPTIONS'], strict_slashes=False)
@inject
def delete_program(id: int, program_service: ProgramService = Provide[Container.program_service]):
    ok = program_service.delete_program(id)
    if not ok:
        return jsonify({'message': 'Program not found'}), 404
    return '', 204
</file>

<file path="api/controllers/program_outcome_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.program_outcome_service import ProgramOutcomeService
from api.schemas.program_outcome_schema import ProgramOutcomeSchema

program_outcome_bp = Blueprint('program_outcome', __name__, url_prefix='/program-outcomes')
schema = ProgramOutcomeSchema()

@program_outcome_bp.route('/program/<int:program_id>', methods=['GET'])
@inject
def list_plos(program_id: int, service: ProgramOutcomeService = Provide[Container.program_outcome_service]):
    items = service.list_by_program(program_id)
    return jsonify(schema.dump(items, many=True)), 200

@program_outcome_bp.route('/', methods=['POST', 'OPTIONS'], strict_slashes=False)
@inject
def create_plo(service: ProgramOutcomeService = Provide[Container.program_outcome_service]):
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    try:
        item = service.create_plo(data)
        return jsonify(schema.dump(item)), 201
    except ValueError as e:
        return jsonify({'error': str(e)}), 400

@program_outcome_bp.route('/<int:id>', methods=['PUT', 'OPTIONS'], strict_slashes=False)
@inject
def update_plo(id: int, service: ProgramOutcomeService = Provide[Container.program_outcome_service]):
    data = request.get_json() or {}
    item = service.update_plo(id, data)
    if not item:
        return jsonify({'message': 'PLO not found'}), 404
    return jsonify(schema.dump(item)), 200

@program_outcome_bp.route('/<int:id>', methods=['DELETE', 'OPTIONS'], strict_slashes=False)
@inject
def delete_plo(id: int, service: ProgramOutcomeService = Provide[Container.program_outcome_service]):
    ok = service.delete_plo(id)
    if not ok:
        return jsonify({'message': 'PLO not found'}), 404
    return '', 204
</file>

<file path="api/controllers/public_controller.py">
"""
Public API endpoints (no authentication required)
For student portal and public access
"""
from flask import Blueprint, jsonify, request
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.syllabus_service import SyllabusService
from api.schemas.syllabus_schema import SyllabusSchema

public_bp = Blueprint('public', __name__, url_prefix='/public')
schema = SyllabusSchema()

@public_bp.route('/syllabus', methods=['GET', 'OPTIONS'], strict_slashes=False)
@inject
def search_public_syllabuses(syllabus_service: SyllabusService = Provide[Container.syllabus_service]):
    """
    Public search for syllabuses (no authentication required)
    Only returns approved/published syllabuses
    ---
    tags:
      - Public
    parameters:
      - name: search
        in: query
        type: string
        description: Search keyword
      - name: subject_id
        in: query
        type: integer
        description: Filter by subject ID
      - name: program_id
        in: query
        type: integer
        description: Filter by program ID
    responses:
      200:
        description: List of public syllabuses
    """
    search = request.args.get('search', '').strip()
    subject_id = request.args.get('subject_id', type=int)
    program_id = request.args.get('program_id', type=int)
    
    # Get all syllabuses and filter for approved/active only
    all_syllabuses = syllabus_service.list_syllabuses() or []
    
    # Filter for public access: only approved and active
    public_syllabuses = [
        s for s in all_syllabuses
        if getattr(s, 'is_active', True) and 
           getattr(s, 'status', '').upper() in ('APPROVED', 'PUBLISHED')
    ]
    
    # Apply search filter
    if search:
        search_lower = search.lower()
        public_syllabuses = [
            s for s in public_syllabuses
            if (hasattr(s, 'subject') and s.subject and search_lower in str(s.subject.name_vi or '').lower()) or
               (hasattr(s, 'subject') and s.subject and search_lower in str(s.subject.name_en or '').lower()) or
               (hasattr(s, 'subject') and s.subject and search_lower in str(s.subject.code or '').lower())
        ]
    
    # Apply subject filter
    if subject_id:
        public_syllabuses = [s for s in public_syllabuses if getattr(s, 'subject_id', None) == subject_id]
    
    # Apply program filter
    if program_id:
        public_syllabuses = [s for s in public_syllabuses if getattr(s, 'program_id', None) == program_id]
    
    return jsonify({
        'data': schema.dump(public_syllabuses, many=True),
        'total': len(public_syllabuses)
    }), 200


@public_bp.route('/syllabus/<int:id>', methods=['GET', 'OPTIONS'], strict_slashes=False)
@inject
def get_public_syllabus(id: int, syllabus_service: SyllabusService = Provide[Container.syllabus_service]):
    """
    Get public syllabus details by ID
    Only returns if approved/published
    ---
    tags:
      - Public
    parameters:
      - name: id
        in: path
        required: true
        type: integer
    responses:
      200:
        description: Syllabus details
      404:
        description: Not found or not public
    """
    syllabus = syllabus_service.get_syllabus(id)
    
    if not syllabus:
        return jsonify({'message': 'Syllabus not found'}), 404
    
    # Check if public
    if not (getattr(syllabus, 'is_active', True) and 
            getattr(syllabus, 'status', '').upper() in ('APPROVED', 'PUBLISHED')):
        return jsonify({'message': 'Syllabus not available'}), 404
    
    return jsonify(schema.dump(syllabus)), 200
</file>

<file path="api/controllers/role_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.role_service import RoleService
from api.schemas.role_schema import RoleSchema

role_bp = Blueprint('role', __name__, url_prefix='/roles')

schema = RoleSchema()

@role_bp.route('/', methods=['GET', 'OPTIONS'], strict_slashes=False)
@inject
def list_roles(role_service: RoleService = Provide[Container.role_service]):
    """Get all roles
    ---
    get:
      summary: Get all roles
      tags:
        - Roles
      responses:
        200:
          description: List of roles
    """
    roles = role_service.list_roles()
    return jsonify(schema.dump(roles, many=True)), 200

@role_bp.route('/', methods=['POST', 'OPTIONS'], strict_slashes=False)
@inject
def create_role(role_service: RoleService = Provide[Container.role_service]):
    """Create a new role
    ---
    post:
      summary: Create a new role
      tags:
        - Roles
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Role'
      responses:
        201:
          description: Role created
        400:
          description: Invalid input
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    role = role_service.create_role(data)
    return jsonify(schema.dump(role)), 201
</file>

<file path="api/controllers/rubric_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.rubric_service import RubricService
from api.schemas.rubric_schema import RubricSchema

rubric_bp = Blueprint('rubric', __name__, url_prefix='/rubrics')

schema = RubricSchema()

@rubric_bp.route('/component/<int:component_id>', methods=['GET'])
@inject
def list_rubrics(component_id: int, rubric_service: RubricService = Provide[Container.rubric_service]):
    """
    List rubrics for a component
    ---
    tags:
      - Rubrics
    parameters:
      - name: component_id
        in: path
        required: true
        schema:
          type: integer
    responses:
      200:
        description: List of rubrics
        content:
          application/json:
            schema:
              type: array
              items:
                $ref: '#/components/schemas/Rubric'
    """
    items = rubric_service.list_rubrics_for_component(component_id)
    return jsonify(schema.dump(items, many=True)), 200

@rubric_bp.route('/', methods=['POST', 'OPTIONS'], strict_slashes=False)
@inject
def create_rubric(rubric_service: RubricService = Provide[Container.rubric_service]):
    """
    Create a rubric
    ---
    tags:
      - Rubrics
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Rubric'
    responses:
      201:
        description: Rubric created
      400:
        description: Validation or creation error
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    try:
        item = rubric_service.create_rubric(data)
    except Exception as e:
        return jsonify({'error': str(e)}), 400
    return jsonify(schema.dump(item)), 201

@rubric_bp.route('/<int:id>', methods=['PUT', 'OPTIONS'], strict_slashes=False)
@inject
def update_rubric(id: int, rubric_service: RubricService = Provide[Container.rubric_service]):
    """
    Update a rubric
    ---
    tags:
      - Rubrics
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: integer
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Rubric'
    responses:
      200:
        description: Rubric updated
      400:
        description: Validation error
      404:
        description: Rubric not found
    """
    data = request.get_json() or {}
    errors = schema.validate(data, partial=True)
    if errors:
        return jsonify(errors), 400
    item = rubric_service.update_rubric(id, data)
    if not item:
        return jsonify({'message': 'Rubric not found'}), 404
    return jsonify(schema.dump(item)), 200

@rubric_bp.route('/<int:id>', methods=['DELETE', 'OPTIONS'], strict_slashes=False)
@inject
def delete_rubric(id: int, rubric_service: RubricService = Provide[Container.rubric_service]):
    """
    Delete a rubric
    ---
    tags:
      - Rubrics
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: integer
    responses:
      204:
        description: Deleted
      404:
        description: Rubric not found
    """
    ok = rubric_service.delete_rubric(id)
    if not ok:
        return jsonify({'message': 'Rubric not found'}), 404
    return '', 204
</file>

<file path="api/controllers/student_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.student_service import StudentService
from api.schemas.student_schema import StudentSubscriptionSchema, StudentReportSchema

student_bp = Blueprint('student', __name__, url_prefix='/student')
sub_schema = StudentSubscriptionSchema()
rep_schema = StudentReportSchema()

@student_bp.route('/subscribe', methods=['POST', 'OPTIONS'], strict_slashes=False)
@inject
def subscribe(service: StudentService = Provide[Container.student_service]):
    """
    Student subscribes to a subject
    ---
    tags:
      - Student Features
    requestBody:
      required: true
      content:
        application/json:
          schema:
            type: object
            properties:
              student_id: {type: integer}
              subject_id: {type: integer}
    responses:
      201:
        description: Subscription created
    """
    data = request.get_json() or {}
    item = service.subscribe(data.get('student_id'), data.get('subject_id'))
    return jsonify(sub_schema.dump(item)), 201

@student_bp.route('/report', methods=['POST', 'OPTIONS'], strict_slashes=False)
@inject
def report(service: StudentService = Provide[Container.student_service]):
    """
    Student reports an issue with a syllabus
    ---
    tags:
      - Student Features
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/StudentReport'
    responses:
      201:
        description: Report created
    """
    data = request.get_json() or {}
    item = service.report_syllabus(data.get('student_id'), data.get('syllabus_id'), data.get('content'))
    return jsonify(rep_schema.dump(item)), 201

@student_bp.route('/reports', methods=['GET', 'OPTIONS'], strict_slashes=False)
@inject
def list_reports(service: StudentService = Provide[Container.student_service]):
    """
    List all student reports (Admin)
    ---
    tags:
      - Student Features
    responses:
      200:
        description: List of reports
    """
    items = service.list_reports()
    return jsonify(rep_schema.dump(items, many=True)), 200
</file>

<file path="api/controllers/subject_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.subject_service import SubjectService
from api.schemas.subject_schema import SubjectSchema

subject_bp = Blueprint('subject', __name__, url_prefix='/subjects')

schema = SubjectSchema()

@subject_bp.route('/', methods=['GET', 'OPTIONS'], strict_slashes=False)
@inject
def list_subjects(subject_service: SubjectService = Provide[Container.subject_service]):
    """Get all subjects
    ---
    get:
      summary: Get all subjects
      tags:
        - Subjects
      responses:
        200:
          description: List of subjects
    """
    subjects = subject_service.list_subjects()
    return jsonify(schema.dump(subjects, many=True)), 200

@subject_bp.route('/<int:id>', methods=['GET', 'OPTIONS'], strict_slashes=False)
@inject
def get_subject(id: int, subject_service: SubjectService = Provide[Container.subject_service]):
    """Get subject by id
    ---
    get:
      summary: Get subject by ID
      tags:
        - Subjects
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        200:
          description: Subject object
        404:
          description: Not found
    """
    subject = subject_service.get_subject(id)
    if not subject:
        return jsonify({'message': 'Subject not found'}), 404
    return jsonify(schema.dump(subject)), 200

@subject_bp.route('/', methods=['POST', 'OPTIONS'], strict_slashes=False)
@inject
def create_subject(subject_service: SubjectService = Provide[Container.subject_service]):
    """Create a new subject
    ---
    post:
      summary: Create a new subject
      tags:
        - Subjects
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Subject'
      responses:
        201:
          description: Subject created
        400:
          description: Invalid input
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    subject = subject_service.create_subject(data)
    return jsonify(schema.dump(subject)), 201

@subject_bp.route('/<int:id>', methods=['PUT', 'OPTIONS'], strict_slashes=False)
@inject
def update_subject(id: int, subject_service: SubjectService = Provide[Container.subject_service]):
    """Update an existing subject
    ---
    put:
      summary: Update subject
      tags:
        - Subjects
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Subject'
      responses:
        200:
          description: Subject updated
        400:
          description: Invalid input
        404:
          description: Subject not found
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    subject = subject_service.update_subject(id, data)
    if not subject:
        return jsonify({'message': 'Subject not found'}), 404
    return jsonify(schema.dump(subject)), 200

@subject_bp.route('/<int:id>', methods=['DELETE', 'OPTIONS'], strict_slashes=False)
@inject
def delete_subject(id: int, subject_service: SubjectService = Provide[Container.subject_service]):
    """Delete subject
    ---
    delete:
      summary: Delete subject
      tags:
        - Subjects
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        204:
          description: Deleted
        404:
          description: Subject not found
    """
    ok = subject_service.delete_subject(id)
    if not ok:
        return jsonify({'message': 'Subject not found'}), 404
    return '', 204
</file>

<file path="api/controllers/subject_relationship_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.subject_relationship_service import SubjectRelationshipService
from api.schemas.subject_relationship_schema import SubjectRelationshipSchema

subject_rel_bp = Blueprint('subject_relationship', __name__, url_prefix='/subject-relationships')
schema = SubjectRelationshipSchema()

@subject_rel_bp.route('/subject/<int:subject_id>', methods=['GET'])
@inject
def list_relationships(subject_id: int, service: SubjectRelationshipService = Provide[Container.subject_relationship_service]):
    """
    List relationships for a subject
    ---
    tags:
      - Subject Relationships
    parameters:
      - name: subject_id
        in: path
        required: true
        schema: {type: integer}
    responses:
      200: {description: List of relationships}
    """
    items = service.get_relationships(subject_id)
    return jsonify(schema.dump(items, many=True)), 200

@subject_rel_bp.route('/', methods=['POST', 'OPTIONS'], strict_slashes=False)
@inject
def create_relationship(service: SubjectRelationshipService = Provide[Container.subject_relationship_service]):
    """
    Create subject relationship
    ---
    tags:
      - Subject Relationships
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/SubjectRelationship'
    responses:
      201: {description: Created}
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    try:
        item = service.add_relationship(data)
        return jsonify(schema.dump(item)), 201
    except ValueError as e:
        return jsonify({'error': str(e)}), 400

@subject_rel_bp.route('/<int:id>', methods=['DELETE', 'OPTIONS'], strict_slashes=False)
@inject
def delete_relationship(id: int, service: SubjectRelationshipService = Provide[Container.subject_relationship_service]):
    """
    Delete relationship
    ---
    tags:
      - Subject Relationships
    responses:
      204: {description: Deleted}
    """
    ok = service.remove_relationship(id)
    if not ok:
        return jsonify({'message': 'Relationship not found'}), 404
    return '', 204
</file>

<file path="api/controllers/syllabus_clo_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.syllabus_clo_service import SyllabusCloService
from api.schemas.syllabus_clo_schema import SyllabusCloSchema

syllabus_clo_bp = Blueprint('syllabus_clo', __name__, url_prefix='/syllabus-clos')

schema = SyllabusCloSchema()

@syllabus_clo_bp.route('/syllabus/<int:syllabus_id>', methods=['GET'])
@inject
def list_clos(syllabus_id: int, syllabus_clo_service: SyllabusCloService = Provide[Container.syllabus_clo_service]):
    """
    List CLOs for a syllabus
    ---
    tags:
      - Syllabus CLOs
    parameters:
      - name: syllabus_id
        in: path
        required: true
        schema:
          type: integer
    responses:
      200:
        description: List of CLOs
        content:
          application/json:
            schema:
              type: array
              items:
                $ref: '#/components/schemas/SyllabusClo'
    """
    items = syllabus_clo_service.get_by_syllabus(syllabus_id)
    return jsonify(schema.dump(items, many=True)), 200

@syllabus_clo_bp.route('/', methods=['POST', 'OPTIONS'], strict_slashes=False)
@inject
def create_clo(syllabus_clo_service: SyllabusCloService = Provide[Container.syllabus_clo_service]):
    """
    Create a new CLO for a syllabus
    ---
    tags:
      - Syllabus CLOs
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/SyllabusClo'
    responses:
      201:
        description: CLO created
      400:
        description: Validation or creation error
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    try:
        item = syllabus_clo_service.create_clo(data)
    except Exception as e:
        return jsonify({'error': str(e)}), 400
    return jsonify(schema.dump(item)), 201

@syllabus_clo_bp.route('/<int:id>', methods=['PUT', 'OPTIONS'], strict_slashes=False)
@inject
def update_clo(id: int, syllabus_clo_service: SyllabusCloService = Provide[Container.syllabus_clo_service]):
    """
    Update an existing CLO
    ---
    tags:
      - Syllabus CLOs
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: integer
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/SyllabusClo'
    responses:
      200:
        description: CLO updated
      400:
        description: Validation error
      404:
        description: CLO not found
    """
    data = request.get_json() or {}
    errors = schema.validate(data, partial=True)
    if errors:
        return jsonify(errors), 400
    item = syllabus_clo_service.update_clo(id, data)
    if not item:
        return jsonify({'message': 'CLO not found'}), 404
    return jsonify(schema.dump(item)), 200

@syllabus_clo_bp.route('/<int:id>', methods=['DELETE', 'OPTIONS'], strict_slashes=False)
@inject
def delete_clo(id: int, syllabus_clo_service: SyllabusCloService = Provide[Container.syllabus_clo_service]):
    """
    Delete a CLO by id
    ---
    tags:
      - Syllabus CLOs
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: integer
    responses:
      204:
        description: Deleted
      404:
        description: CLO not found
    """
    ok = syllabus_clo_service.delete_clo(id)
    if not ok:
        return jsonify({'message': 'CLO not found'}), 404
    return '', 204
</file>

<file path="api/controllers/syllabus_comment_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.syllabus_comment_service import SyllabusCommentService
from api.schemas.syllabus_comment_schema import SyllabusCommentSchema

syllabus_comment_bp = Blueprint('syllabus_comment', __name__, url_prefix='/syllabus-comments')
schema = SyllabusCommentSchema()

@syllabus_comment_bp.route('/syllabus/<int:syllabus_id>', methods=['GET'])
@inject
def list_comments(syllabus_id: int, service: SyllabusCommentService = Provide[Container.syllabus_comment_service]):
    """
    List comments for syllabus
    ---
    tags:
      - Comments
    parameters:
      - name: syllabus_id
        in: path
        required: true
        schema: {type: integer}
    responses:
      200: {description: List of comments}
    """
    items = service.get_comments(syllabus_id)
    return jsonify(schema.dump(items, many=True)), 200

@syllabus_comment_bp.route('/', methods=['POST', 'OPTIONS'], strict_slashes=False)
@inject
def add_comment(service: SyllabusCommentService = Provide[Container.syllabus_comment_service]):
    """
    Add a comment
    ---
    tags:
      - Comments
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/SyllabusComment'
    responses:
      201: {description: Created}
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    try:
        item = service.add_comment(data)
        return jsonify(schema.dump(item)), 201
    except ValueError as e:
        return jsonify({'error': str(e)}), 400

@syllabus_comment_bp.route('/<int:id>/resolve', methods=['PUT', 'OPTIONS'], strict_slashes=False)
@inject
def resolve_comment(id: int, service: SyllabusCommentService = Provide[Container.syllabus_comment_service]):
    """
    Mark comment as resolved
    ---
    tags:
      - Comments
    responses:
      200: {description: Resolved}
    """
    item = service.resolve_comment(id)
    if not item:
        return jsonify({'message': 'Comment not found'}), 404
    return jsonify(schema.dump(item)), 200

@syllabus_comment_bp.route('/<int:id>', methods=['DELETE', 'OPTIONS'], strict_slashes=False)
@inject
def delete_comment(id: int, service: SyllabusCommentService = Provide[Container.syllabus_comment_service]):
    """
    Delete comment
    ---
    tags:
      - Comments
    responses:
      204: {description: Deleted}
    """
    ok = service.delete_comment(id)
    if not ok:
        return jsonify({'message': 'Comment not found'}), 404
    return '', 204
</file>

<file path="api/controllers/syllabus_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.syllabus_service import SyllabusService
from api.schemas.syllabus_schema import SyllabusSchema
from api.schemas.syllabus_detail_schema import SyllabusDetailSchema
from api.middleware import token_required
from utils.pagination import get_pagination_params, Pagination
from utils.performance import log_api_request

syllabus_bp = Blueprint('syllabus', __name__, url_prefix='/syllabuses')

schema = SyllabusSchema()
detail_schema = SyllabusDetailSchema()

@syllabus_bp.route('/', methods=['GET', 'OPTIONS'], strict_slashes=False)
@inject
@log_api_request
def list_syllabuses(syllabus_service: SyllabusService = Provide[Container.syllabus_service]):
    """List syllabuses with pagination
    ---
    get:
      summary: List syllabuses (supports pagination)
      tags:
        - Syllabuses
      parameters:
        - name: page
          in: query
          schema:
            type: integer
            default: 1
        - name: page_size
          in: query
          schema:
            type: integer
            default: 20
      responses:
        200:
          description: Paginated list of syllabuses
    """
    # Get pagination params
    page, page_size, _ = get_pagination_params(default_page_size=20, max_page_size=100)
    
    # Check if pagination requested
    if 'page' in request.args or 'page_size' in request.args:
        items, total = syllabus_service.list_syllabuses_paginated(page, page_size)
        pagination = Pagination(schema.dump(items, many=True), page, page_size, total)
        return jsonify(pagination.to_dict()), 200
    else:
        # Legacy support: return all items
        items = syllabus_service.list_syllabuses()
        return jsonify(schema.dump(items, many=True)), 200

@syllabus_bp.route('/<int:id>', methods=['GET', 'OPTIONS'], strict_slashes=False)
@inject
def get_syllabus(id: int, syllabus_service: SyllabusService = Provide[Container.syllabus_service]):
    """Get syllabus
    ---
    get:
      summary: Get syllabus by id
      tags:
        - Syllabuses
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        200:
          description: Syllabus object
        404:
          description: Not found
    """
    s = syllabus_service.get_syllabus(id)
    if not s:
        return jsonify({'message': 'Syllabus not found'}), 404
    return jsonify(schema.dump(s)), 200


@syllabus_bp.route('/<int:id>/details', methods=['GET', 'OPTIONS'], strict_slashes=False)
@inject
def get_syllabus_details(id: int, syllabus_service: SyllabusService = Provide[Container.syllabus_service]):
    """Get full syllabus details
    ---
    get:
      summary: Get syllabus details by id
      tags:
        - Syllabuses
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        200:
          description: Syllabus detail object
        404:
          description: Not found
    """
    s = syllabus_service.get_syllabus_details(id)
    if not s:
        return jsonify({'message': 'Syllabus not found'}), 404
    return jsonify(detail_schema.dump(s)), 200


@syllabus_bp.route('/compare', methods=['GET', 'OPTIONS'], strict_slashes=False)
@inject
def compare_syllabuses(syllabus_service: SyllabusService = Provide[Container.syllabus_service]):
    """Compare two syllabuses by id
    ---
    get:
      summary: Compare two syllabuses
      tags:
        - Syllabuses
      parameters:
        - name: base_id
          in: query
          required: true
          schema:
            type: integer
        - name: target_id
          in: query
          required: true
          schema:
            type: integer
    responses:
      200:
        description: Differences between the two syllabuses
      404:
        description: Syllabus not found
    """
    try:
        base_id = int(request.args.get('baseId') or request.args.get('base_id'))
        target_id = int(request.args.get('targetId') or request.args.get('target_id'))
    except Exception:
        return jsonify({'message': 'base_id and target_id query parameters are required and must be integers'}), 400

    base = syllabus_service.get_syllabus_details(base_id)
    target = syllabus_service.get_syllabus_details(target_id)

    if not base or not target:
        return jsonify({'message': 'One or both syllabuses not found'}), 404

    # Fields to compare
    fields = ['subject_name_vi', 'credits', 'description', 'student_duties']
    diffs = []
    for f in fields:
        base_val = getattr(base, f, None)
        target_val = getattr(target, f, None)
        if base_val != target_val:
            diffs.append({'field': f, 'base': base_val, 'target': target_val})

    # Compare CLO counts
    base_clos = getattr(base, 'clos', []) or []
    target_clos = getattr(target, 'clos', []) or []
    if len(base_clos) != len(target_clos):
        diffs.append({'field': 'clos_count', 'base': len(base_clos), 'target': len(target_clos)})

    return jsonify({'diffs': diffs}), 200


@syllabus_bp.route('/<int:id>/submit', methods=['POST', 'OPTIONS'], strict_slashes=False)
@token_required
@inject
def submit_syllabus(id: int, syllabus_service: SyllabusService = Provide[Container.syllabus_service]):
    """Submit a syllabus for evaluation (requires authentication)
    ---
    post:
      summary: Submit syllabus
      tags:
        - Syllabuses
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      requestBody:
        required: true
      responses:
        200:
          description: Submitted syllabus
        400:
          description: Invalid action
        401:
          description: Unauthorized
        404:
          description: Not found
    """
    from flask import g
    user_id = getattr(g, 'user_id', None)
    
    if not user_id:
        return jsonify({'message': 'User not authenticated'}), 401
    
    try:
        s = syllabus_service.submit_syllabus(id, user_id)
    except ValueError as e:
        return jsonify({'message': str(e)}), 422
    except Exception as e:
        return jsonify({'message': f'Error submitting syllabus: {str(e)}'}), 500
    
    if not s:
        return jsonify({'message': 'Syllabus not found'}), 404
    
    return jsonify({'message': 'Syllabus submitted successfully', 'data': schema.dump(s)}), 200


@syllabus_bp.route('/<int:id>/evaluate', methods=['POST', 'OPTIONS'], strict_slashes=False)
@token_required
@inject
def evaluate_syllabus(id: int, syllabus_service: SyllabusService = Provide[Container.syllabus_service]):
    """Evaluate (approve/reject) a syllabus (requires authentication)
    ---
    post:
      summary: Evaluate syllabus
      tags:
        - Syllabuses
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      requestBody:
        required: true
      responses:
        200:
          description: Evaluation result
        400:
          description: Invalid action or missing comment
        401:
          description: Unauthorized
        404:
          description: Not found
    """
    from flask import g
    user_id = getattr(g, 'user_id', None)
    
    if not user_id:
        return jsonify({'message': 'User not authenticated'}), 401
    
    data = request.get_json() or {}
    action = data.get('action')
    comment = data.get('comment')
    
    if not action:
        return jsonify({'message': 'action is required'}), 422
    
    try:
        s = syllabus_service.evaluate_syllabus(id, user_id, action, comment)
    except ValueError as e:
        return jsonify({'message': str(e)}), 422
    except Exception as e:
        return jsonify({'message': f'Error evaluating syllabus: {str(e)}'}), 500
    
    if not s:
        return jsonify({'message': 'Syllabus not found'}), 404
    
    return jsonify({'message': 'Evaluation completed', 'data': schema.dump(s)}), 200


@syllabus_bp.route('/<int:id>/workflow-logs', methods=['GET', 'OPTIONS'], strict_slashes=False)
@inject
def get_workflow_logs(id: int, syllabus_service: SyllabusService = Provide[Container.syllabus_service]):
    """Get workflow logs for a syllabus
    ---
    get:
      summary: Get workflow logs
      tags:
        - Syllabuses
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        200:
          description: List of workflow logs
        404:
          description: Not found
    """
    logs = syllabus_service.get_workflow_logs(id)
    from api.schemas.workflow_log_schema import WorkflowLogSchema
    schema_w = WorkflowLogSchema()
    return jsonify(schema_w.dump(logs, many=True)), 200

@syllabus_bp.route('/', methods=['POST', 'OPTIONS'], strict_slashes=False)
@inject
@token_required
def create_syllabus(syllabus_service: SyllabusService = Provide[Container.syllabus_service]):
    """Create a syllabus
    ---
    post:
      summary: Create syllabus
      tags:
        - Syllabuses
      requestBody:
        required: true
      responses:
        201:
          description: Created
        400:
          description: Invalid input
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    try:
        s = syllabus_service.create_syllabus(data)
    except Exception as e:
        return jsonify({'error': str(e)}), 400
    return jsonify(schema.dump(s)), 201

@syllabus_bp.route('/<int:id>', methods=['PUT', 'OPTIONS'], strict_slashes=False)
@inject
def update_syllabus(id: int, syllabus_service: SyllabusService = Provide[Container.syllabus_service]):
    data = request.get_json() or {}
    errors = schema.validate(data, partial=True)
    if errors:
        return jsonify(errors), 400
    s = syllabus_service.update_syllabus(id, data)
    if not s:
        return jsonify({'message': 'Syllabus not found'}), 404
    return jsonify(schema.dump(s)), 200

@syllabus_bp.route('/<int:id>', methods=['DELETE', 'OPTIONS'], strict_slashes=False)
@inject
def delete_syllabus(id: int, syllabus_service: SyllabusService = Provide[Container.syllabus_service]):
    ok = syllabus_service.delete_syllabus(id)
    if not ok:
        return jsonify({'message': 'Syllabus not found'}), 404
    return '', 204
</file>

<file path="api/controllers/syllabus_material_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.syllabus_material_service import SyllabusMaterialService
from api.schemas.syllabus_material_schema import SyllabusMaterialSchema

syllabus_material_bp = Blueprint('syllabus_material', __name__, url_prefix='/syllabus-materials')

schema = SyllabusMaterialSchema()

@syllabus_material_bp.route('/syllabus/<int:syllabus_id>', methods=['GET'])
@inject
def list_materials(syllabus_id: int, syllabus_material_service: SyllabusMaterialService = Provide[Container.syllabus_material_service]):
    """
    List materials for a syllabus
    ---
    tags:
      - Syllabus Materials
    parameters:
      - name: syllabus_id
        in: path
        required: true
        schema:
          type: integer
    responses:
      200:
        description: List of materials
        content:
          application/json:
            schema:
              type: array
              items:
                $ref: '#/components/schemas/SyllabusMaterial'
    """
    items = syllabus_material_service.get_by_syllabus(syllabus_id)
    return jsonify(schema.dump(items, many=True)), 200

@syllabus_material_bp.route('/', methods=['POST', 'OPTIONS'], strict_slashes=False)
@inject
def create_material(syllabus_material_service: SyllabusMaterialService = Provide[Container.syllabus_material_service]):
    """
    Create a syllabus material
    ---
    tags:
      - Syllabus Materials
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/SyllabusMaterial'
    responses:
      201:
        description: Material created
      400:
        description: Validation or creation error
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    try:
        item = syllabus_material_service.create_material(data)
    except Exception as e:
        return jsonify({'error': str(e)}), 400
    return jsonify(schema.dump(item)), 201

@syllabus_material_bp.route('/<int:id>', methods=['DELETE', 'OPTIONS'], strict_slashes=False)
@inject
def delete_material(id: int, syllabus_material_service: SyllabusMaterialService = Provide[Container.syllabus_material_service]):
    """
    Delete a syllabus material
    ---
    tags:
      - Syllabus Materials
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: integer
    responses:
      204:
        description: Deleted
      404:
        description: Material not found
    """
    ok = syllabus_material_service.delete_material(id)
    if not ok:
        return jsonify({'message': 'Material not found'}), 404
    return '', 204
</file>

<file path="api/controllers/system_setting_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.system_setting_service import SystemSettingService
from api.schemas.system_setting_schema import SystemSettingSchema

system_setting_bp = Blueprint('system_setting', __name__, url_prefix='/system-settings')
schema = SystemSettingSchema()

@system_setting_bp.route('/', methods=['GET', 'OPTIONS'], strict_slashes=False)
@inject
def list_settings(service: SystemSettingService = Provide[Container.system_setting_service]):
    """
    List all system settings
    ---
    tags:
      - System Settings
    responses:
      200:
        description: List of settings
    """
    items = service.get_all_settings()
    return jsonify(schema.dump(items, many=True)), 200

@system_setting_bp.route('/', methods=['POST', 'OPTIONS'], strict_slashes=False)
@inject
def update_setting(service: SystemSettingService = Provide[Container.system_setting_service]):
    """
    Update or create a system setting
    ---
    tags:
      - System Settings
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/SystemSetting'
    responses:
      200:
        description: Setting updated
      400:
        description: Validation error
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    item = service.update_setting(data['key'], data['value'], data.get('description'))
    return jsonify(schema.dump(item)), 200
</file>

<file path="api/controllers/teaching_plan_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.teaching_plan_service import TeachingPlanService
from api.schemas.teaching_plan_schema import TeachingPlanSchema

teaching_plan_bp = Blueprint('teaching_plan', __name__, url_prefix='/teaching-plans')

schema = TeachingPlanSchema()

@teaching_plan_bp.route('/syllabus/<int:syllabus_id>', methods=['GET'])
@inject
def list_plans(syllabus_id: int, teaching_plan_service: TeachingPlanService = Provide[Container.teaching_plan_service]):
    """
    List teaching plans for a syllabus
    ---
    tags:
      - Teaching Plans
    parameters:
      - name: syllabus_id
        in: path
        required: true
        schema:
          type: integer
    responses:
      200:
        description: List of teaching plans
        content:
          application/json:
            schema:
              type: array
              items:
                $ref: '#/components/schemas/TeachingPlan'
    """
    items = teaching_plan_service.list_plans_for_syllabus(syllabus_id)
    return jsonify(schema.dump(items, many=True)), 200

@teaching_plan_bp.route('/', methods=['POST', 'OPTIONS'], strict_slashes=False)
@inject
def create_plan(teaching_plan_service: TeachingPlanService = Provide[Container.teaching_plan_service]):
    """
    Create a teaching plan
    ---
    tags:
      - Teaching Plans
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/TeachingPlan'
    responses:
      201:
        description: Teaching plan created
      400:
        description: Validation or creation error
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    try:
        item = teaching_plan_service.create_teaching_plan(data)
    except Exception as e:
        return jsonify({'error': str(e)}), 400
    return jsonify(schema.dump(item)), 201

@teaching_plan_bp.route('/<int:id>', methods=['PUT', 'OPTIONS'], strict_slashes=False)
@inject
def update_plan(id: int, teaching_plan_service: TeachingPlanService = Provide[Container.teaching_plan_service]):
    """
    Update a teaching plan
    ---
    tags:
      - Teaching Plans
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: integer
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/TeachingPlan'
    responses:
      200:
        description: Teaching plan updated
      400:
        description: Validation error
      404:
        description: Teaching plan not found
    """
    data = request.get_json() or {}
    errors = schema.validate(data, partial=True)
    if errors:
        return jsonify(errors), 400
    item = teaching_plan_service.update_teaching_plan(id, data)
    if not item:
        return jsonify({'message': 'Teaching plan not found'}), 404
    return jsonify(schema.dump(item)), 200

@teaching_plan_bp.route('/<int:id>', methods=['DELETE', 'OPTIONS'], strict_slashes=False)
@inject
def delete_plan(id: int, teaching_plan_service: TeachingPlanService = Provide[Container.teaching_plan_service]):
    """
    Delete a teaching plan
    ---
    tags:
      - Teaching Plans
    parameters:
      - name: id
        in: path
        required: true
        schema:
          type: integer
    responses:
      204:
        description: Deleted
      404:
        description: Teaching plan not found
    """
    ok = teaching_plan_service.delete_teaching_plan(id)
    if not ok:
        return jsonify({'message': 'Teaching plan not found'}), 404
    return '', 204
</file>

<file path="api/controllers/user_controller.py">
from flask import Blueprint, request, jsonify
from dependency_injector.wiring import inject, Provide
from dependency_container import Container
from services.user_service import UserService
from api.schemas.user_schema import UserSchema
from api.middleware import token_required

user_bp = Blueprint('user', __name__, url_prefix='/users')

schema = UserSchema()

@user_bp.route('/', methods=['GET', 'OPTIONS'], strict_slashes=False)
@inject
def list_users(user_service: UserService = Provide[Container.user_service]):
    """Get all users
    ---
    get:
      summary: Get all users
      tags:
        - Users
      responses:
        200:
          description: List of users
    """
    users = user_service.list_users()
    return jsonify(schema.dump(users, many=True)), 200

@user_bp.route('/<int:id>', methods=['GET', 'OPTIONS'], strict_slashes=False)
@inject
def get_user(id: int, user_service: UserService = Provide[Container.user_service]):
    """Get user by id
    ---
    get:
      summary: Get user by ID
      tags:
        - Users
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        200:
          description: User object
        404:
          description: Not found
    """
    user = user_service.get_user(id)
    if not user:
        return jsonify({'message': 'User not found'}), 404
    return jsonify(schema.dump(user)), 200


@user_bp.route('/<int:id>', methods=['DELETE', 'OPTIONS'], strict_slashes=False)
@inject
def delete_user(id: int, user_service: UserService = Provide[Container.user_service]):
    """
    Delete a user
    ---
    delete:
      summary: Delete user by ID
      tags:
        - Users
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        200:
          description: User deleted successfully
        404:
          description: User not found
    """
    success = user_service.delete_user(id)
    if not success:
        return jsonify({'message': 'User not found'}), 404
    return jsonify({'message': 'User deleted successfully'}), 200


@user_bp.route('/me', methods=['GET', 'OPTIONS'], strict_slashes=False)
@inject
@token_required
def get_me(user_service: UserService = Provide[Container.user_service]):
    """
    Get current user from token
    """
    from flask import g
    user_id = getattr(g, 'user_id', None)
    if not user_id:
        return jsonify({'message': 'User not found in token'}), 401
    user = user_service.get_user(user_id)
    if not user:
        return jsonify({'message': 'User not found'}), 404
    
    # Get role name from user
    role_name = None
    try:
        if user.roles and len(user.roles) > 0 and getattr(user.roles[0], 'role', None):
            role_name = user.roles[0].role.name
    except Exception:
        role_name = None
    
    # Build response with role
    user_data = schema.dump(user)
    user_data['role'] = role_name
    
    return jsonify(user_data), 200

@user_bp.route('/', methods=['POST', 'OPTIONS'], strict_slashes=False)
@inject
def create_user(user_service: UserService = Provide[Container.user_service]):
    """Create a new user
    ---
    post:
      summary: Create a new user
      tags:
        - Users
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/User'
      responses:
        201:
          description: User created
        400:
          description: Invalid input
    """
    data = request.get_json() or {}
    errors = schema.validate(data)
    if errors:
        return jsonify(errors), 400
    user = user_service.create_user(data)
    return jsonify(schema.dump(user)), 201

@user_bp.route('/<int:id>', methods=['PUT', 'OPTIONS'], strict_slashes=False)
@inject
def update_user(id: int, user_service: UserService = Provide[Container.user_service]):
    """Update an existing user
    ---
    put:
      summary: Update user
      tags:
        - Users
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/User'
      responses:
        200:
          description: User updated
        400:
          description: Invalid input
        404:
          description: User not found
    """
    data = request.get_json() or {}
    errors = schema.validate(data, partial=True)
    if errors:
        return jsonify(errors), 400
    user = user_service.update_user(id, data)
    if not user:
        return jsonify({'message': 'User not found'}), 404
    return jsonify(schema.dump(user)), 200
</file>

<file path="api/middleware.py">
# Middleware functions for processing requests and responses

from flask import  request, jsonify

def log_request_info(app):
    app.logger.debug('Headers: %s', request.headers)
    app.logger.debug('Body: %s', request.get_data())

def handle_options_request():
    return jsonify({'message': 'CORS preflight response'}), 200

from flask import current_app
from werkzeug.exceptions import HTTPException
import traceback

def error_handling_middleware(error):
    # Handle HTTP exceptions (e.g., BadRequest) with their status codes
    if isinstance(error, HTTPException):
        response = jsonify({'error': error.description})
        response.status_code = error.code or 400
        return response

    # Log unexpected exceptions with traceback
    try:
        current_app.logger.exception(error)
    except Exception:
        pass

    tb = None
    try:
        tb = traceback.format_exc()
    except Exception:
        tb = None

    payload = {'error': str(error)}
    if getattr(current_app, 'debug', False) and tb:
        payload['traceback'] = tb

    response = jsonify(payload)
    response.status_code = 500
    return response

def add_custom_headers(response):
    response.headers['X-Custom-Header'] = 'Value'
    return response

from functools import wraps


def middleware(app):
    @app.before_request
    def before_request():
        log_request_info(app)

    @app.after_request
    def after_request(response):
        return add_custom_headers(response)

    @app.errorhandler(Exception)
    def handle_exception(error):
        return error_handling_middleware(error)

    @app.route('/options', methods=['OPTIONS'])
    def options_route():
        return handle_options_request()


# Token decorator verifying JWT
import jwt
from config import Config

def token_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        from flask import request, make_response, g
        # Allow preflight CORS requests through without authentication
        if request.method == 'OPTIONS':
            return make_response('', 200)
        auth = request.headers.get('Authorization', '')
        if not auth or not auth.startswith('Bearer '):
            return jsonify({'message': 'Authorization token is missing'}), 401
        token = auth.split(' ', 1)[1]
        try:
            payload = jwt.decode(token, Config.SECRET_KEY, algorithms=['HS256'])
            # Attach user info to Flask g context
            g.user_id = payload.get('user_id')
            g.username = payload.get('username')
            g.role = payload.get('role')
        except jwt.ExpiredSignatureError:
            return jsonify({'message': 'Token expired'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'message': 'Invalid token'}), 401
        return f(*args, **kwargs)

    return decorated
</file>

<file path="api/requests.py">
# requests.py

from flask import request, jsonify

def get_request_data():
    """Extracts and returns JSON data from the request."""
    data = request.get_json()
    if not data:
        return jsonify({"error": "No data provided"}), 400
    return data

def validate_request_schema(schema):
    """Validates the incoming request data against the provided schema."""
    data = get_request_data()
    errors = schema.validate(data)
    if errors:
        return jsonify({"errors": errors}), 400
    return data

def handle_get_request():
    """Handles GET requests."""
    # Logic for handling GET requests goes here
    pass

def handle_post_request():
    """Handles POST requests."""
    # Logic for handling POST requests goes here
    pass

def handle_put_request():
    """Handles PUT requests."""
    # Logic for handling PUT requests goes here
    pass

def handle_delete_request():
    """Handles DELETE requests."""
    # Logic for handling DELETE requests goes here
    pass
</file>

<file path="api/responses.py">
# src/api/responses.py

from flask import jsonify

def success_response(data, message="Success"):
    return jsonify({"message": message, "data": data}), 200

def error_response(message="An error occurred", status_code=400):
    return jsonify({"message": message}), status_code

def not_found_response(message="Resource not found"):
    return jsonify({"message": message}), 404

def validation_error_response(errors):
    return jsonify({"message": "Validation errors", "errors": errors}), 422
</file>

<file path="api/routes.py">
def register_routes(app):
    """Register API routes. No legacy route blueprints are registered for SMD."""
    return
</file>

<file path="api/schemas/...  # Marshmallow schemas">
# This file is intentionally left blank.
</file>

<file path="api/schemas/academic_year_schema.py">
from marshmallow import Schema, fields

class AcademicYearSchema(Schema):
    id = fields.Int(dump_only=True)
    code = fields.Str(required=True)
    start_date = fields.Date(required=True)
    end_date = fields.Date(required=True)
</file>

<file path="api/schemas/assessment_clo_mapping_schema.py">
from marshmallow import Schema, fields

class AssessmentCloMappingSchema(Schema):
    assessment_component_id = fields.Int(required=True)
    syllabus_clo_id = fields.Int(required=True)
</file>

<file path="api/schemas/assessment_component_schema.py">
from marshmallow import Schema, fields
from marshmallow.validate import Range

class AssessmentComponentSchema(Schema):
    id = fields.Int(dump_only=True)
    scheme_id = fields.Int(required=True)
    name = fields.Str(required=True)
    weight = fields.Float(required=True, validate=Range(min=0, max=100))
    rubrics = fields.List(fields.Nested('RubricSchema'), dump_only=True)
</file>

<file path="api/schemas/assessment_scheme_schema.py">
from marshmallow import Schema, fields
from marshmallow.validate import Range

class AssessmentSchemeSchema(Schema):
    id = fields.Int(dump_only=True)
    syllabus_id = fields.Int(required=True)
    name = fields.Str(required=True)
    weight = fields.Float(required=True, validate=Range(min=0, max=100))
    components = fields.List(fields.Nested('AssessmentComponentSchema'), dump_only=True)
</file>

<file path="api/schemas/base_schema.py">
from marshmallow import Schema, post_dump
import re

def snake_to_camel(s: str) -> str:
    parts = s.split('_')
    return parts[0] + ''.join(p.capitalize() for p in parts[1:])

def _convert(obj):
    if isinstance(obj, dict):
        new = {}
        for k, v in obj.items():
            nk = snake_to_camel(k)
            new[nk] = _convert(v)
        return new
    elif isinstance(obj, list):
        return [_convert(x) for x in obj]
    else:
        return obj

class BaseSchema(Schema):
    @post_dump
    def to_camel(self, data, many=False, **kwargs):
        # marshmallow may or may not pass `many`; accept it optionally
        if many and isinstance(data, list):
            return [_convert(x) for x in data]
        return _convert(data)
</file>

<file path="api/schemas/clo_plo_mapping_schema.py">
from marshmallow import Schema, fields
from marshmallow.validate import OneOf

class CloPloMappingSchema(Schema):
    id = fields.Int(dump_only=True)
    syllabus_clo_id = fields.Int(required=True)
    program_plo_id = fields.Int(required=True)
    level = fields.Str(required=True, validate=OneOf(['I', 'R', 'M', 'A']))
</file>

<file path="api/schemas/department_schema.py">
from marshmallow import Schema, fields

class DepartmentSchema(Schema):
    id = fields.Int(dump_only=True)
    faculty_id = fields.Int(required=True)
    code = fields.Str(required=True)
    name = fields.Str(required=True)
</file>

<file path="api/schemas/faculty_schema.py">
from marshmallow import Schema, fields

class FacultySchema(Schema):
    id = fields.Int(dump_only=True)
    code = fields.Str(required=True)
    name = fields.Str(required=True)
    # Optional fields example: use load_default for Marshmallow
    description = fields.Str(load_default=None)
</file>

<file path="api/schemas/file_schema.py">
from marshmallow import Schema, fields

class FileSchema(Schema):
    id = fields.Int(dump_only=True)
    uploader_id = fields.Int(dump_only=True)
    file_name = fields.Str(dump_only=True)
    file_path = fields.Str(dump_only=True)
    created_at = fields.DateTime(dump_only=True)
</file>

<file path="api/schemas/notification_schema.py">
from marshmallow import Schema, fields

class NotificationSchema(Schema):
    id = fields.Int(dump_only=True)
    user_id = fields.Int(required=True)
    title = fields.Str(required=True)
    message = fields.Str(load_default=None)
    link = fields.Str(load_default=None)
    is_read = fields.Bool(dump_only=True)
    type = fields.Str(load_default='SYSTEM')
    created_at = fields.DateTime(dump_only=True)
</file>

<file path="api/schemas/program_outcome_schema.py">
from marshmallow import Schema, fields

class ProgramOutcomeSchema(Schema):
    id = fields.Int(dump_only=True)
    program_id = fields.Int(required=True)
    code = fields.Str(required=True)
    description = fields.Str(required=True)
</file>

<file path="api/schemas/program_schema.py">
from marshmallow import Schema, fields

class ProgramSchema(Schema):
    id = fields.Int(dump_only=True)
    department_id = fields.Int(required=True)
    name = fields.Str(required=True)
    total_credits = fields.Int(load_default=0)
</file>

<file path="api/schemas/role_schema.py">
from marshmallow import Schema, fields

class RoleSchema(Schema):
    id = fields.Int(dump_only=True)
    name = fields.Str(required=True)
    description = fields.Str(load_default=None)
</file>

<file path="api/schemas/rubric_schema.py">
from marshmallow import Schema, fields

class RubricSchema(Schema):
    id = fields.Int(dump_only=True)
    component_id = fields.Int(required=True)
    criteria = fields.Str(required=True)
    max_score = fields.Float(required=True)
    description_level_pass = fields.Str(load_default=None)
    description_level_fail = fields.Str(load_default=None)
</file>

<file path="api/schemas/student_schema.py">
from marshmallow import Schema, fields

class StudentSubscriptionSchema(Schema):
    id = fields.Int(dump_only=True)
    student_id = fields.Int(required=True)
    subject_id = fields.Int(required=True)
    created_at = fields.DateTime(dump_only=True)

class StudentReportSchema(Schema):
    id = fields.Int(dump_only=True)
    syllabus_id = fields.Int(required=True)
    student_id = fields.Int(required=True)
    content = fields.Str(required=True)
    status = fields.Str(dump_only=True)
    admin_note = fields.Str(load_default=None)
</file>

<file path="api/schemas/subject_relationship_schema.py">
from marshmallow import Schema, fields
from marshmallow.validate import OneOf

class SubjectRelationshipSchema(Schema):
    id = fields.Int(dump_only=True)
    subject_id = fields.Int(required=True)
    related_subject_id = fields.Int(required=True)
    type = fields.Str(required=True, validate=OneOf(['PREREQUISITE', 'COREQUISITE', 'PARALLEL']))
</file>

<file path="api/schemas/subject_schema.py">
# from marshmallow import Schema, fields

# class SubjectSchema(Schema):
#     id = fields.Int(dump_only=True)
#     department_id = fields.Int(required=True)
#     code = fields.Str(required=True)
#     name_vi = fields.Str(required=True)
#     name_en = fields.Str(required=True)
#     credits = fields.Int(required=True)
#     credit_theory = fields.Float(missing=0)
#     credit_practice = fields.Float(missing=0)
#     credit_self_study = fields.Float(missing=0)
from marshmallow import Schema, fields

class SubjectSchema(Schema):
    id = fields.Int(dump_only=True)
    department_id = fields.Int(required=True)
    code = fields.Str(required=True)
    name_vi = fields.Str(required=True)
    name_en = fields.Str(required=True)
    credits = fields.Int(required=True)
    # Sửa missing=0 thành load_default=0
    credit_theory = fields.Float(load_default=0)
    credit_practice = fields.Float(load_default=0)
    credit_self_study = fields.Float(load_default=0)
</file>

<file path="api/schemas/syllabus_clo_schema.py">
from marshmallow import Schema, fields

class SyllabusCloSchema(Schema):
    id = fields.Int(dump_only=True)
    syllabus_id = fields.Int(required=True)
    code = fields.Str(required=True)
    description = fields.Str(required=True)
    created_at = fields.DateTime(dump_only=True)
</file>

<file path="api/schemas/syllabus_comment_schema.py">
from marshmallow import Schema, fields

class SyllabusCommentSchema(Schema):
    id = fields.Int(dump_only=True)
    syllabus_id = fields.Int(required=True)
    user_id = fields.Int(required=True)
    content = fields.Str(required=True)
    parent_id = fields.Int(load_default=None)
    is_resolved = fields.Bool(dump_only=True)
    created_at = fields.DateTime(dump_only=True)
</file>

<file path="api/schemas/syllabus_detail_schema.py">
from marshmallow import fields
from .base_schema import BaseSchema

class SyllabusDetailSchema(BaseSchema):
    id = fields.Int(dump_only=True)
    subject_id = fields.Int(required=True)
    program_id = fields.Int(required=True)
    academic_year_id = fields.Int(required=True)
    lecturer_id = fields.Int(required=True)

    status = fields.Str(dump_only=True)
    version = fields.Str(dump_default="1.0")
    time_allocation = fields.Str(load_default=None)
    prerequisites = fields.Str(load_default=None)
    publish_date = fields.DateTime(load_default=None)

    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)

    clos = fields.List(fields.Nested('SyllabusCloSchema'), dump_only=True)
    materials = fields.List(fields.Nested('SyllabusMaterialSchema'), dump_only=True)
    teaching_plans = fields.List(fields.Nested('TeachingPlanSchema'), dump_only=True)
    assessment_schemes = fields.List(fields.Nested('AssessmentSchemeSchema'), dump_only=True)
</file>

<file path="api/schemas/syllabus_material_schema.py">
from marshmallow import Schema, fields

class SyllabusMaterialSchema(Schema):
    id = fields.Int(dump_only=True)
    syllabus_id = fields.Int(required=True)
    type = fields.Str(required=True)
    title = fields.Str(required=True)
    author = fields.Str(load_default=None)
    publisher = fields.Str(load_default=None)
    isbn = fields.Str(load_default=None)
    url = fields.Str(load_default=None)
</file>

<file path="api/schemas/syllabus_schema.py">
import json
from marshmallow import fields, post_dump
from marshmallow.validate import Length
from .base_schema import BaseSchema

class SyllabusSchema(BaseSchema):
    id = fields.Int(dump_only=True)
    subject_id = fields.Int(required=True)
    program_id = fields.Int(required=True)
    academic_year_id = fields.Int(required=True)
    lecturer_id = fields.Int(required=True)

    status = fields.Str(dump_only=True)
    version = fields.Str(load_default="1.0", validate=Length(max=10))
    
    # FIX: time_allocation as Dict -> Use Raw to accept DB-stored JSON string
    time_allocation = fields.Raw(allow_none=True)  # Changed from Dict to Raw to handle DB String
    prerequisites = fields.Str(load_default=None)
    publish_date = fields.DateTime(load_default=None)

    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)

    # FIX: Add nested fields for input (load_default=[])
    clos = fields.List(fields.Nested('SyllabusCloSchema'), load_default=[])
    materials = fields.List(fields.Nested('SyllabusMaterialSchema'), load_default=[])
    teaching_plans = fields.List(fields.Nested('TeachingPlanSchema'), load_default=[])
    assessment_schemes = fields.List(fields.Nested('AssessmentSchemeSchema'), load_default=[])

    @post_dump
    def parse_json(self, data, **kwargs):
        if 'timeAllocation' in data and isinstance(data['timeAllocation'], str):
            try:
                data['timeAllocation'] = json.loads(data['timeAllocation'])
            except:
                pass
        return data
</file>

<file path="api/schemas/system_setting_schema.py">
from marshmallow import Schema, fields

class SystemSettingSchema(Schema):
    key = fields.Str(required=True)
    value = fields.Str(required=True)
    type = fields.Str(dump_only=True)
    description = fields.Str(load_default=None)
</file>

<file path="api/schemas/teaching_plan_schema.py">
from marshmallow import Schema, fields

class TeachingPlanSchema(Schema):
    id = fields.Int(dump_only=True)
    syllabus_id = fields.Int(required=True)
    week = fields.Int(required=True)
    topic = fields.Str(load_default=None)
    activity = fields.Str(load_default=None)
    assessment = fields.Str(load_default=None)
    created_at = fields.DateTime(dump_only=True)
    updated_at = fields.DateTime(dump_only=True)
</file>

<file path="api/schemas/user_schema.py">
from marshmallow import fields
from .base_schema import BaseSchema

class UserSchema(BaseSchema):
    id = fields.Int(dump_only=True)
    username = fields.Str(required=True)
    email = fields.Email(required=True)
    full_name = fields.Str(required=True)
    department_id = fields.Int(load_default=None)
    is_active = fields.Bool(load_default=True)
    password = fields.Str(load_only=True, required=True)
</file>

<file path="api/schemas/user.py">

</file>

<file path="api/schemas/workflow_log_schema.py">
from marshmallow import Schema, fields

class WorkflowLogSchema(Schema):
    id = fields.Int(dump_only=True)
    syllabus_id = fields.Int(required=True)
    actor_id = fields.Int(required=True)
    action = fields.Str(required=True)
    from_status = fields.Str(load_default=None)
    to_status = fields.Str(load_default=None)
    comment = fields.Str(load_default=None)
    created_at = fields.DateTime(dump_only=True)
</file>

<file path="api/swagger.py">
from apispec import APISpec
from apispec.ext.marshmallow import MarshmallowPlugin
from apispec_webframeworks.flask import FlaskPlugin

spec = APISpec(
    title="Syllabus Management API",
    version="1.0.0",
    openapi_version="3.0.2",
    plugins=[FlaskPlugin(), MarshmallowPlugin()],
)

# (No legacy Todo schemas registered — SMD module schemas are registered via controllers/schemas)
</file>

<file path="app_logging.py">
import logging

def setup_logging():
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler("app.log"),
            logging.StreamHandler()
        ]
    )

setup_logging()
</file>

<file path="app.py">
from flask import Flask, jsonify
from api.swagger import spec
from api.middleware import middleware
from infrastructure.databases import init_db
from flasgger import Swagger
from flask_swagger_ui import get_swaggerui_blueprint
from cors import init_cors

# Dependency injection
from dependency_container import Container
from api.controllers.subject_controller import subject_bp
from api.controllers.faculty_controller import faculty_bp
from api.controllers.department_controller import department_bp
from api.controllers.role_controller import role_bp
from api.controllers.user_controller import user_bp
from api.controllers.academic_year_controller import academic_year_bp
from api.controllers.program_controller import program_bp
from api.controllers.syllabus_controller import syllabus_bp
from api.controllers.syllabus_clo_controller import syllabus_clo_bp
from api.controllers.syllabus_material_controller import syllabus_material_bp
from api.controllers.teaching_plan_controller import teaching_plan_bp
from api.controllers.assessment_scheme_controller import assessment_scheme_bp
from api.controllers.assessment_component_controller import assessment_component_bp
from api.controllers.rubric_controller import rubric_bp
from api.controllers.assessment_clo_controller import assessment_clo_bp
from api.controllers.auth_controller import auth_bp
from api.controllers.ai_controller import ai_bp
from api.controllers.dashboard_controller import dashboard_bp
from api.controllers.program_outcome_controller import program_outcome_bp
from api.controllers.file_controller import file_bp
from api.controllers.clo_plo_mapping_controller import clo_plo_mapping_bp
from api.controllers.subject_relationship_controller import subject_rel_bp
from api.controllers.syllabus_comment_controller import syllabus_comment_bp
from api.controllers.notification_controller import notification_bp
from api.controllers.system_setting_controller import system_setting_bp
from api.controllers.student_controller import student_bp
from api.controllers.public_controller import public_bp


def create_app():
    app = Flask(__name__)

    # Initialize CORS early so Swagger and other blueprints respect it
    try:
        init_cors(app)
    except Exception:
        pass

    Swagger(app)

    # Initialize DI container and wire controllers
    container = Container()
    # Wire the container explicitly for controllers
    try:
        container.wire(modules=[
            "api.controllers.subject_controller",
            "api.controllers.faculty_controller",
            "api.controllers.department_controller",
            "api.controllers.role_controller",
            "api.controllers.user_controller",
            "api.controllers.academic_year_controller",
            "api.controllers.program_controller",
            "api.controllers.syllabus_controller",
            "api.controllers.syllabus_clo_controller",
            "api.controllers.syllabus_material_controller",
            "api.controllers.teaching_plan_controller",
            "api.controllers.assessment_scheme_controller",
            "api.controllers.assessment_component_controller",
            "api.controllers.rubric_controller",
            "api.controllers.assessment_clo_controller",
            "api.controllers.auth_controller",
            "api.controllers.ai_controller",
            "api.controllers.dashboard_controller",
            "api.controllers.program_outcome_controller",
            "api.controllers.file_controller",
            "api.controllers.clo_plo_mapping_controller",
            "api.controllers.subject_relationship_controller",
            "api.controllers.syllabus_comment_controller",
            "api.controllers.notification_controller",
            "api.controllers.system_setting_controller",
            "api.controllers.student_controller",
            "api.controllers.public_controller",
        ])
        print("[OK] Dependency injection wiring successful")
    except Exception as e:
        error_msg = f"Failed to wire dependency container: {e}"
        print(f"[ERROR] {error_msg}")
        import os
        # In production, fail fast; in development, allow partial wiring
        if os.getenv('ENVIRONMENT', 'development') == 'production':
            raise RuntimeError(error_msg)
        else:
            print("[WARNING] Continuing with incomplete DI wiring in development mode")

    # Register blueprints
    app.register_blueprint(subject_bp)
    app.register_blueprint(faculty_bp)
    app.register_blueprint(department_bp)
    app.register_blueprint(role_bp)
    app.register_blueprint(user_bp)
    app.register_blueprint(academic_year_bp)
    app.register_blueprint(program_bp)
    app.register_blueprint(syllabus_bp)
    app.register_blueprint(syllabus_clo_bp)
    app.register_blueprint(syllabus_material_bp)
    app.register_blueprint(teaching_plan_bp)
    app.register_blueprint(assessment_scheme_bp)
    app.register_blueprint(assessment_component_bp)
    app.register_blueprint(rubric_bp)
    app.register_blueprint(assessment_clo_bp)
    app.register_blueprint(auth_bp)
    app.register_blueprint(ai_bp)
    app.register_blueprint(dashboard_bp)
    app.register_blueprint(program_outcome_bp)
    app.register_blueprint(file_bp)
    app.register_blueprint(clo_plo_mapping_bp)
    app.register_blueprint(subject_rel_bp)
    app.register_blueprint(syllabus_comment_bp)
    app.register_blueprint(notification_bp)
    app.register_blueprint(system_setting_bp)
    app.register_blueprint(student_bp)
    app.register_blueprint(public_bp)

     # Thêm Swagger UI blueprint
    SWAGGER_URL = '/docs'
    API_URL = '/swagger.json'
    swaggerui_blueprint = get_swaggerui_blueprint(
        SWAGGER_URL,
        API_URL,
        config={'app_name': "Syllabus Management API"}
    )
    app.register_blueprint(swaggerui_blueprint, url_prefix=SWAGGER_URL)

    # Database initialization with proper error handling
    try:
        init_db(app)
        print("[OK] Database initialized successfully")
    except Exception as e:
        print(f"[ERROR] Error initializing database: {e}")
        import os
        if os.getenv('ENVIRONMENT', 'development') == 'production':
            raise

    # Register middleware
    middleware(app)
    print("[OK] Middleware registered")

    # Initialize CORS
    try:
        init_cors(app)
    except Exception:
        pass

    # Register routes (add all non-static endpoints to Swagger where possible)
    with app.test_request_context():
        for rule in app.url_map.iter_rules():
            if rule.endpoint == 'static':
                continue
            view_func = app.view_functions.get(rule.endpoint)
            if not view_func:
                continue
            try:
                spec.path(view=view_func)
                print(f"Adding path: {rule.rule} -> {view_func}")
            except Exception:
                # some endpoints may not be compatible with flasgger, skip them
                pass

    @app.route("/swagger.json")
    def swagger_json():
        return jsonify(spec.to_dict())

    return app
# Run the application

if __name__ == '__main__':
    app = create_app()
    app.run(host='0.0.0.0', port=5000, debug=True)
</file>

<file path="config.py">
# Configuration settings for the Flask application

import os
from dotenv import load_dotenv
load_dotenv()

class Config:
    """Base configuration."""
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'a_default_secret_key'
    DEBUG = os.environ.get('DEBUG', 'False').lower() in ['true', '1']
    TESTING = os.environ.get('TESTING', 'False').lower() in ['true', '1']
    
    DATABASE_URI = os.environ.get('DATABASE_URI') 
    CORS_HEADERS = 'Content-Type'
    
    # Logging Configuration
    LOG_LEVEL = os.environ.get('LOG_LEVEL', 'INFO')
    LOG_DIR = os.environ.get('LOG_DIR', 'logs')
    
    # Caching Configuration
    CACHE_TYPE = os.environ.get('CACHE_TYPE', 'SimpleCache')
    CACHE_DEFAULT_TIMEOUT = int(os.environ.get('CACHE_DEFAULT_TIMEOUT', 300))
    CACHE_REDIS_URL = os.environ.get('CACHE_REDIS_URL')
    
    # Pagination
    DEFAULT_PAGE_SIZE = int(os.environ.get('DEFAULT_PAGE_SIZE', 20))
    MAX_PAGE_SIZE = int(os.environ.get('MAX_PAGE_SIZE', 100))

class DevelopmentConfig(Config):
    """Development configuration."""
    DEBUG = True
    DATABASE_URI = os.environ.get('DATABASE_URI')
    LOG_LEVEL = 'DEBUG'
    CACHE_TYPE = 'SimpleCache' 


class TestingConfig(Config):
    """Testing configuration."""
    TESTING = True
    DATABASE_URI = os.environ.get('DATABASE_URI')


class ProductionConfig(Config):
    """Production configuration."""
    DATABASE_URI = os.environ.get('DATABASE_URI')
    LOG_LEVEL = 'WARNING'
    CACHE_TYPE = 'RedisCache'  # Use Redis in production
    DEBUG = False 

    
template = {
    "swagger": "2.0",
    "info": {
        "title": "Syllabus Management API",
        "description": "API for Syllabus Management (SMD)",
        "version": "1.0.0"
    },
    "basePath": "/",
    "schemes": [
        "http",
        "https"
    ],
    "consumes": [
        "application/json"
    ],
    "produces": [
        "application/json"
    ]
}
class SwaggerConfig:
    """Swagger configuration."""
    template = {
        "swagger": "2.0",
        "info": {
            "title": "Syllabus Management API",
            "description": "API for Syllabus Management (SMD)",
            "version": "1.0.0"
        },
        "basePath": "/",
        "schemes": [
            "http",
            "https"
        ],
        "consumes": [
            "application/json"
        ],
        "produces": [
            "application/json"
        ]
    }

    swagger_config = {
        "headers": [],
        "specs": [
            {
                "endpoint": 'apispec',
                "route": '/apispec.json',
                "rule_filter": lambda rule: True,
                "model_filter": lambda tag: True,
            }
        ],
        "static_url_path": "/flasgger_static",
        "swagger_ui": True,
        "specs_route": "/docs"
    }
</file>

<file path="cors.py">
from flask_cors import CORS

def init_cors(app):
    # Allow multiple origins including localhost variants
    CORS(app, resources={
        r"/*": {
            "origins": ["http://localhost:3000", "http://127.0.0.1:3000", "http://localhost:3001"],
            "allow_headers": ["Authorization", "Content-Type", "X-Requested-With"],
            "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"],
            "expose_headers": ["Content-Type", "Authorization"],
            "supports_credentials": True,
            "max_age": 3600
        }
    }, supports_credentials=True)
    app.config.setdefault('CORS_HEADERS', 'Content-Type')
    return app
</file>

<file path="create_app.py">
from flask import Flask
from config import Config
from api.middleware import middleware
from api.routes import register_routes
from infrastructure.databases import init_db
from utils.caching import cache
from utils.logging_config import setup_logging as setup_structured_logging

def create_app():
    app = Flask(__name__)
    app.config.from_object(Config)

    # Setup structured logging
    setup_structured_logging(
        app_name=app.config.get('APP_NAME', 'smd-api'),
        log_level=app.config.get('LOG_LEVEL', 'INFO'),
        log_dir=app.config.get('LOG_DIR', 'logs')
    )
    
    # Setup Flask-Caching
    cache.init_app(app, config={
        'CACHE_TYPE': app.config.get('CACHE_TYPE', 'SimpleCache'),
        'CACHE_DEFAULT_TIMEOUT': app.config.get('CACHE_DEFAULT_TIMEOUT', 300),
        'CACHE_REDIS_URL': app.config.get('CACHE_REDIS_URL')
    })

    init_db(app)
    middleware(app)
    register_routes(app)

    return app
</file>

<file path="dependency_container.py">
# Dependency Injection Container

from dependency_injector import containers, providers
from infrastructure.databases.mssql import SessionLocal

from infrastructure.repositories.subject_repository import SubjectRepository
from services.subject_service import SubjectService
from infrastructure.repositories.faculty_repository import FacultyRepository
from services.faculty_service import FacultyService
from infrastructure.repositories.department_repository import DepartmentRepository
from services.department_service import DepartmentService
from infrastructure.repositories.role_repository import RoleRepository
from services.role_service import RoleService
from infrastructure.repositories.user_repository import UserRepository
from services.user_service import UserService
from infrastructure.repositories.academic_year_repository import AcademicYearRepository
from services.academic_year_service import AcademicYearService
from infrastructure.repositories.program_repository import ProgramRepository
from services.program_service import ProgramService
from infrastructure.repositories.syllabus_repository import SyllabusRepository
from services.syllabus_service import SyllabusService
from infrastructure.repositories.syllabus_clo_repository import SyllabusCloRepository
from services.syllabus_clo_service import SyllabusCloService
from infrastructure.repositories.syllabus_material_repository import SyllabusMaterialRepository
from services.syllabus_material_service import SyllabusMaterialService
from infrastructure.repositories.teaching_plan_repository import TeachingPlanRepository
from services.teaching_plan_service import TeachingPlanService
from infrastructure.repositories.assessment_scheme_repository import AssessmentSchemeRepository
from services.assessment_scheme_service import AssessmentSchemeService
from infrastructure.repositories.assessment_component_repository import AssessmentComponentRepository
from services.assessment_component_service import AssessmentComponentService
from infrastructure.repositories.rubric_repository import RubricRepository
from services.rubric_service import RubricService
from infrastructure.repositories.assessment_clo_repository import AssessmentCloRepository
from services.assessment_clo_service import AssessmentCloService
from infrastructure.repositories.workflow_log_repository import WorkflowLogRepository

# NEW: Program Outcome, File Management, Mappings, Relationships, Comments, Notifications, System Settings, AI Audit
from infrastructure.repositories.program_outcome_repository import ProgramOutcomeRepository
from services.program_outcome_service import ProgramOutcomeService
from infrastructure.repositories.file_repository import FileRepository
from services.file_service import FileService
from infrastructure.repositories.clo_plo_mapping_repository import CloPloMappingRepository
from services.clo_plo_mapping_service import CloPloMappingService
from infrastructure.repositories.subject_relationship_repository import SubjectRelationshipRepository
from services.subject_relationship_service import SubjectRelationshipService
from infrastructure.repositories.syllabus_comment_repository import SyllabusCommentRepository
from services.syllabus_comment_service import SyllabusCommentService
from infrastructure.repositories.notification_repository import NotificationRepository
from services.notification_service import NotificationService
from infrastructure.repositories.system_setting_repository import SystemSettingRepository
from infrastructure.repositories.ai_auditlog_repository import AiAuditLogRepository
from infrastructure.repositories.notification_repository import NotificationRepository
from infrastructure.repositories.student_subscription_repository import StudentSubscriptionRepository
from infrastructure.repositories.student_report_repository import StudentReportRepository
from services.system_setting_service import SystemSettingService
from services.student_service import StudentService

class Container(containers.DeclarativeContainer):
    """Dependency Injection Container for SMD services."""

    wiring_config = containers.WiringConfiguration(modules=[
        "api.controllers.subject_controller",
        "api.controllers.faculty_controller",
        "api.controllers.department_controller",
        "api.controllers.role_controller",
        "api.controllers.user_controller",
        "api.controllers.academic_year_controller",
        "api.controllers.program_controller",
        "api.controllers.syllabus_controller",
        "api.controllers.syllabus_clo_controller",
        "api.controllers.syllabus_material_controller",
        "api.controllers.teaching_plan_controller",
        "api.controllers.assessment_scheme_controller",
        "api.controllers.assessment_component_controller",
        "api.controllers.rubric_controller",
        "api.controllers.assessment_clo_controller",
        "api.controllers.auth_controller",
        "api.controllers.ai_controller",
        "api.controllers.dashboard_controller",
        "api.controllers.program_outcome_controller",
        "api.controllers.file_controller",
        "api.controllers.clo_plo_mapping_controller",
        "api.controllers.subject_relationship_controller",
        "api.controllers.syllabus_comment_controller",
        "api.controllers.notification_controller",
        "api.controllers.system_setting_controller",
        "api.controllers.student_controller",
    ])

    # Provide a session factory (creates new session per injection)
    from infrastructure.databases.mssql import SessionLocal
    db_session = providers.Factory(SessionLocal)

    # Repositories
    subject_repository = providers.Factory(
        SubjectRepository,
        session=db_session
    )

    faculty_repository = providers.Factory(
        FacultyRepository,
        session=db_session
    )

    department_repository = providers.Factory(
        DepartmentRepository,
        session=db_session
    )

    academic_year_repository = providers.Factory(
        AcademicYearRepository,
        session=db_session
    )

    program_repository = providers.Factory(
        ProgramRepository,
        session=db_session
    )

    role_repository = providers.Factory(
        RoleRepository,
        session=db_session
    )

    user_repository = providers.Factory(
        UserRepository,
        session=db_session
    )
    # Services
    subject_service = providers.Factory(
        SubjectService,
        repository=subject_repository
    )

    faculty_service = providers.Factory(
        FacultyService,
        repository=faculty_repository
    )

    department_service = providers.Factory(
        DepartmentService,
        repository=department_repository
    )

    syllabus_repository = providers.Factory(
        SyllabusRepository,
        session=db_session
    )

    syllabus_clo_repository = providers.Factory(
        SyllabusCloRepository,
        session=db_session
    )

    syllabus_material_repository = providers.Factory(
        SyllabusMaterialRepository,
        session=db_session
    )

    teaching_plan_repository = providers.Factory(
        TeachingPlanRepository,
        session=db_session
    )

    assessment_scheme_repository = providers.Factory(
        AssessmentSchemeRepository,
        session=db_session
    )

    assessment_component_repository = providers.Factory(
        AssessmentComponentRepository,
        session=db_session
    )

    rubric_repository = providers.Factory(
        RubricRepository,
        session=db_session
    )

    assessment_clo_repository = providers.Factory(
        AssessmentCloRepository,
        session=db_session
    )

    workflow_log_repository = providers.Factory(
        WorkflowLogRepository,
        session=db_session
    )

    # NEW REPOSITORIES
    program_outcome_repository = providers.Factory(
        ProgramOutcomeRepository,
        session=db_session
    )
    
    file_repository = providers.Factory(
        FileRepository,
        session=db_session
    )

    clo_plo_mapping_repository = providers.Factory(
        CloPloMappingRepository,
        session=db_session
    )

    subject_relationship_repository = providers.Factory(
        SubjectRelationshipRepository,
        session=db_session
    )

    syllabus_comment_repository = providers.Factory(
        SyllabusCommentRepository,
        session=db_session
    )

    notification_repository = providers.Factory(
        NotificationRepository,
        session=db_session
    )

    system_setting_repository = providers.Factory(
        SystemSettingRepository,
        session=db_session
    )

    student_subscription_repository = providers.Factory(
        StudentSubscriptionRepository,
        session=db_session
    )

    student_report_repository = providers.Factory(
        StudentReportRepository,
        session=db_session
    )

    ai_auditlog_repository = providers.Factory(
        AiAuditLogRepository,
        session=db_session
    )

    academic_year_service = providers.Factory(
        AcademicYearService,
        repository=academic_year_repository
    )

    program_service = providers.Factory(
        ProgramService,
        repository=program_repository
    )

    syllabus_service = providers.Factory(
        SyllabusService,
        repository=syllabus_repository,
        subject_repository=subject_repository,
        program_repository=program_repository,
        academic_year_repository=academic_year_repository,
        user_repository=user_repository,
        workflow_log_repository=workflow_log_repository,
        # NEW INJECTIONS:
        syllabus_clo_repository=syllabus_clo_repository,
        syllabus_material_repository=syllabus_material_repository,
        teaching_plan_repository=teaching_plan_repository,
        assessment_scheme_repository=assessment_scheme_repository,
        assessment_component_repository=assessment_component_repository,
        rubric_repository=rubric_repository,
        assessment_clo_repository=assessment_clo_repository
    )

    syllabus_clo_service = providers.Factory(
        SyllabusCloService,
        repository=syllabus_clo_repository,
        syllabus_repository=syllabus_repository
    )

    syllabus_material_service = providers.Factory(
        SyllabusMaterialService,
        repository=syllabus_material_repository,
        syllabus_repository=syllabus_repository
    )

    teaching_plan_service = providers.Factory(
        TeachingPlanService,
        repository=teaching_plan_repository,
        syllabus_repository=syllabus_repository
    )

    assessment_scheme_service = providers.Factory(
        AssessmentSchemeService,
        repository=assessment_scheme_repository,
        syllabus_repository=syllabus_repository
    )

    assessment_component_service = providers.Factory(
        AssessmentComponentService,
        repository=assessment_component_repository,
        scheme_repository=assessment_scheme_repository
    )

    rubric_service = providers.Factory(
        RubricService,
        repository=rubric_repository,
        component_repository=assessment_component_repository
    )

    assessment_clo_service = providers.Factory(
        AssessmentCloService,
        repository=assessment_clo_repository,
        component_repository=assessment_component_repository,
        syllabus_clo_repository=syllabus_clo_repository,
        assessment_scheme_repository=assessment_scheme_repository
    )
  

    # NEW SERVICES
    program_outcome_service = providers.Factory(
        ProgramOutcomeService,
        repository=program_outcome_repository,
        program_repository=program_repository
    )

    file_service = providers.Factory(
        FileService,
        repository=file_repository
    )

    clo_plo_mapping_service = providers.Factory(
        CloPloMappingService,
        repository=clo_plo_mapping_repository,
        syllabus_clo_repository=syllabus_clo_repository,
        program_outcome_repository=program_outcome_repository
    )

    subject_relationship_service = providers.Factory(
        SubjectRelationshipService,
        repository=subject_relationship_repository,
        subject_repository=subject_repository
    )

    syllabus_comment_service = providers.Factory(
        SyllabusCommentService,
        repository=syllabus_comment_repository,
        syllabus_repository=syllabus_repository,
        user_repository=user_repository
    )

    notification_service = providers.Factory(
        NotificationService,
        repository=notification_repository,
        user_repository=user_repository
    )

    system_setting_service = providers.Factory(
        SystemSettingService,
        repository=system_setting_repository
    )

    student_service = providers.Factory(
        StudentService, 
        sub_repo=student_subscription_repository,
        report_repo=student_report_repository
    )

    # AI Service (inject audit repository)
    from services.ai_service import AiService
    ai_service = providers.Factory(
        AiService,
        audit_repository=ai_auditlog_repository
    )

    role_service = providers.Factory(
        RoleService,
        repository=role_repository
    )

    user_service = providers.Factory(
        UserService,
        repository=user_repository
    )
</file>

<file path="domain/constants.py">
# Constants

# Define any constants used throughout the application here. 
# For example, you might define API version, error messages, or configuration keys.

API_VERSION = "v1"
DEFAULT_PAGE_SIZE = 20
MAX_PAGE_SIZE = 100

# Workflow Status Constants
class WorkflowStatus:
    """Syllabus workflow status constants."""
    DRAFT = 'DRAFT'
    PENDING = 'PENDING'
    APPROVED = 'APPROVED'
    REJECTED = 'REJECTED'
    
    # Valid states for each action
    VALID_FOR_SUBMISSION = (DRAFT, REJECTED)
    VALID_FOR_EVALUATION = (PENDING,)
    
    ALL_STATES = (DRAFT, PENDING, APPROVED, REJECTED)

# Add more constants as needed for your application.
</file>

<file path="domain/exceptions.py">
class CustomException(Exception):
    """Base class for all custom exceptions in the application."""
    pass

class NotFoundException(CustomException):
    """Exception raised when a resource is not found."""
    def __init__(self, message="Resource not found"):
        self.message = message
        super().__init__(self.message)

class ValidationException(CustomException):
    """Exception raised for validation errors."""
    def __init__(self, message="Validation error"):
        self.message = message
        super().__init__(self.message)

class UnauthorizedException(CustomException):
    """Exception raised for unauthorized access."""
    def __init__(self, message="Unauthorized access"):
        self.message = message
        super().__init__(self.message)

class ConflictException(CustomException):
    """Exception raised for conflicts in the application."""
    def __init__(self, message="Conflict occurred"):
        self.message = message
        super().__init__(self.message)
</file>

<file path="domain/models/...  # Business logic models">
# This file is intentionally left blank.
</file>

<file path="domain/models/user.py">
from sqlalchemy import Column, Integer, String, DateTime, Boolean
from infrastructure.databases.base import Base

class User:
    
    def __innit__(self, user_name: str, password: str, description: str = None, status: bool = True):
        self.user_name = user_name
        self.password = password
        self.description = description
        self.status = status
        self.created_at = None
        self.updated_at = None
</file>

<file path="error_handler.py">
# Error handling logic for the Flask application

from flask import jsonify

class CustomError(Exception):
    status_code = 400

    def __init__(self, message, status_code=None):
        super().__init__(message)
        if status_code is not None:
            self.status_code = status_code
        self.message = message

    def to_dict(self):
        return {'message': self.message}

def handle_error(error):
    if isinstance(error, CustomError):
        response = jsonify(error.to_dict())
        response.status_code = error.status_code
        return response

    response = jsonify({'message': 'An unexpected error occurred.'})
    response.status_code = 500
    return response

def register_error_handlers(app):
    app.register_error_handler(Exception, handle_error)
</file>

<file path="infrastructure/databases/__init__.py">
from infrastructure.databases.mssql import init_mssql
from infrastructure.models import (
    academic_year_model,
    ai_auditlog_model,
    assessment_clo_model,
    assessment_component_model,
    assessment_scheme_model,
    clo_plo_mapping_model,
    department_model,
    faculty_model,
    file_model,
    notification_model,
    notification_template_model,
    program_model,
    program_outcome_model,
    role_model,
    rubric_model,
    student_report_model,
    student_subscription_model,
    subject_model,
    subject_relationship_model,
    syllabus_clo_model,
    syllabus_comment_model,
    syllabus_current_workflow,
    syllabus_material_model,
    syllabus_model,
    system_auditlog_model,
    system_setting_model,
    teaching_plan_model,
    user_model,
    user_role_model,
    workflow_log_model,
    workflow_state_model,
    workflow_transition_model
)

def init_db(app):
    init_mssql(app)

# Migration Entities -> tables
from infrastructure.databases.mssql import Base
</file>

<file path="infrastructure/databases/base.py">
from sqlalchemy.orm import declarative_base

Base = declarative_base()


# ORM: object relational mapping base class
# OOP : object oriented programming

# ERD --> class relational
# Lập trinhf hướng đối tượng (logic) mapping class -> table (database)
</file>

<file path="infrastructure/databases/mssql.py">
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.pool import QueuePool
from config import Config
from infrastructure.databases.base import Base

# Database configuration
DATABASE_URI = Config.DATABASE_URI

# Configure engine with proper connection pooling
engine = create_engine(
    DATABASE_URI,
    poolclass=QueuePool,
    pool_size=20,              # Connection pool size
    max_overflow=40,           # Additional connections beyond pool_size
    pool_pre_ping=True,        # Verify connection before use
    pool_recycle=3600,         # Recycle connection after 1 hour
    echo=Config.DEBUG,         # Log SQL queries in debug mode
    connect_args={
        'timeout': 30
    }
)

SessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine,
    expire_on_commit=False     # Don't expire objects after commit
)

# Create a default session for backward compatibility (not recommended for use)
# NOTE: DI Container should use SessionLocal() factory instead
session = SessionLocal()

def init_mssql(app):
    """Initialize database with proper error handling."""
    try:
        Base.metadata.create_all(bind=engine)
        app.logger.info("✓ Database tables created successfully")
    except Exception as e:
        app.logger.error(f"✗ Failed to create database tables: {e}")
        raise
</file>

<file path="infrastructure/databases/mysql.py">

</file>

<file path="infrastructure/models/__init__.py">
from .user_model import User
from .user_role_model import UserRole
from .role_model import Role
from .faculty_model import Faculty
from .department_model import Department
from .program_model import Program
from .program_outcome_model import ProgramOutcome
from .subject_model import Subject
from .academic_year_model import AcademicYear
from .syllabus_model import Syllabus
from .syllabus_clo_model import SyllabusClo
from .syllabus_material_model import SyllabusMaterial
from .teaching_plan_model import TeachingPlan
from .assessment_scheme_model import AssessmentScheme
from .assessment_component_model import AssessmentComponent
from .rubric_model import Rubric
from .clo_plo_mapping_model import CloPloMapping
from .assessment_clo_model import AssessmentClo
from .subject_relationship_model import SubjectRelationship
from .system_setting_model import SystemSetting
from .student_subscription_model import StudentSubscription
from .student_report_model import StudentReport
from .notification_model import Notification
from .syllabus_comment_model import SyllabusComment
from .workflow_log_model import WorkflowLog
from .workflow_state_model import WorkflowState
from .workflow_transition_model import WorkflowTransition
from .syllabus_current_workflow import SyllabusCurrentWorkflow
from .ai_auditlog_model import AiAuditLog

__all__ = [
    "User", "UserRole", "Role", "Faculty", "Department", "Program",
    "ProgramOutcome", "Subject", "AcademicYear", "Syllabus", "SyllabusClo",
    "SyllabusMaterial", "TeachingPlan", "AssessmentScheme", "AssessmentComponent", "Rubric",
    "CloPloMapping", "AssessmentClo", "SubjectRelationship", "SystemSetting",
    "StudentSubscription", "StudentReport", "Notification", "SyllabusComment",
    "WorkflowLog", "WorkflowState", "WorkflowTransition", "SyllabusCurrentWorkflow",
    "AiAuditLog"
]
</file>

<file path="infrastructure/models/academic_year_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class AcademicYear(Base):
    __tablename__ = 'academic_years'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    code = Column(NVARCHAR(20), unique=True)
    start_date = Column(Date)
    end_date = Column(Date)
    
    # Relationships
    syllabuses = relationship("Syllabus", back_populates="academic_year")
</file>

<file path="infrastructure/models/ai_auditlog_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class AiAuditLog(Base):
    __tablename__ = 'ai_audit_logs'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    syllabus_id = Column(BigInteger, ForeignKey('syllabuses.id'), nullable=False)
    action = Column(NVARCHAR(50))  # GENERATE, COMPARE_DIFF, SUMMARIZE
    input_tokens = Column(Integer)
    output_tokens = Column(Integer)
    created_at = Column(DateTime, default=func.now())
    
    # Relationships
    syllabus = relationship("Syllabus", back_populates="ai_audit_logs")
</file>

<file path="infrastructure/models/assessment_clo_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class AssessmentClo(Base):
    __tablename__ = 'assessment_clos'
    
    assessment_component_id = Column(BigInteger, ForeignKey('assessment_components.id'), primary_key=True)
    syllabus_clo_id = Column(BigInteger, ForeignKey('syllabus_clos.id'), primary_key=True)
    
    # Relationships
    component = relationship("AssessmentComponent", back_populates="clos")
    syllabus_clo = relationship("SyllabusClo", back_populates="assessment_clos")
</file>

<file path="infrastructure/models/assessment_component_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class AssessmentComponent(Base):
    __tablename__ = 'assessment_components'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    scheme_id = Column(BigInteger, ForeignKey('assessment_schemes.id'), nullable=False)
    name = Column(NVARCHAR(255), nullable=False)
    weight = Column(DECIMAL(3, 1), nullable=False)
    
    # Relationships
    scheme = relationship("AssessmentScheme", back_populates="components")
    clos = relationship("AssessmentClo", back_populates="component")
    rubrics = relationship("Rubric", back_populates="component", cascade="all, delete-orphan")
</file>

<file path="infrastructure/models/assessment_scheme_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class AssessmentScheme(Base):
    __tablename__ = 'assessment_schemes'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    syllabus_id = Column(BigInteger, ForeignKey('syllabuses.id', ondelete='CASCADE'), nullable=False)
    name = Column(NVARCHAR(100))
    weight = Column(DECIMAL(3, 1))
    
    # Relationships
    syllabus = relationship("Syllabus", back_populates="assessment_schemes")
    components = relationship("AssessmentComponent", back_populates="scheme", cascade="all, delete-orphan")
</file>

<file path="infrastructure/models/clo_plo_mapping_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class CloPloMapping(Base):
    __tablename__ = 'clo_plo_mappings'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    syllabus_clo_id = Column(BigInteger, ForeignKey('syllabus_clos.id', ondelete='CASCADE'), nullable=False)
    program_plo_id = Column(BigInteger, ForeignKey('program_outcomes.id'), nullable=False)
    level = Column(NVARCHAR(1))  # I, R, M, A
    
    __table_args__ = (
        CheckConstraint("level IN ('I', 'R', 'M', 'A')", name='check_level'),
    )
    
    # Relationships
    syllabus_clo = relationship("SyllabusClo", back_populates="plo_mappings")
    program_plo = relationship("ProgramOutcome", back_populates="clo_mappings")
</file>

<file path="infrastructure/models/department_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class Department(Base):
    __tablename__ = 'departments'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    faculty_id = Column(BigInteger, ForeignKey('faculties.id'), nullable=False)
    code = Column(NVARCHAR(20), unique=True, nullable=False)
    name = Column(NVARCHAR(255), nullable=False)
    
    # Relationships
    faculty = relationship("Faculty", back_populates="departments")
    users = relationship("User", back_populates="department")
    subjects = relationship("Subject", back_populates="department")
    programs = relationship("Program", back_populates="department")
</file>

<file path="infrastructure/models/faculty_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base


class Faculty(Base):
    __tablename__ = 'faculties'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    code = Column(NVARCHAR(20), unique=True, nullable=False)
    name = Column(NVARCHAR(255), nullable=False)
    
    # Relationships
    departments = relationship("Department", back_populates="faculty")
</file>

<file path="infrastructure/models/file_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
# IMPORT BASE CHUNG (QUAN TRỌNG)
from infrastructure.databases.base import Base

class File(Base):
    __tablename__ = 'files'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    uploader_id = Column(BigInteger, ForeignKey('users.id'), nullable=False)
    file_name = Column(NVARCHAR(255), nullable=False)
    file_path = Column(NVARCHAR(500), nullable=False)
    file_size = Column(BigInteger)
    mime_type = Column(NVARCHAR(100))
    created_at = Column(DateTime, default=func.now())
    
    # Relationships
    uploader = relationship("User", back_populates="uploaded_files", foreign_keys=[uploader_id])
</file>

<file path="infrastructure/models/notification_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class Notification(Base):
    __tablename__ = 'notifications'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    user_id = Column(BigInteger, ForeignKey('users.id'), nullable=False)
    title = Column(NVARCHAR(255), nullable=False)
    message = Column(UnicodeText)
    link = Column(NVARCHAR(500))
    is_read = Column(Boolean, default=False)
    type = Column(NVARCHAR(50))  # SYSTEM, REVIEW, REMINDER
    created_at = Column(DateTime, default=func.now())
    
    # Relationships
    user = relationship("User", back_populates="notifications")
</file>

<file path="infrastructure/models/notification_template_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class NotificationTemplate(Base):
    __tablename__ = 'notification_templates'
    
    code = Column(NVARCHAR(50), primary_key=True)
    title_template = Column(NVARCHAR(255), nullable=False)
    body_template = Column(UnicodeText, nullable=False)
    channel = Column(NVARCHAR(20), default='SYSTEM')  # EMAIL, SMS, SYSTEM
</file>

<file path="infrastructure/models/program_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class Program(Base):
    __tablename__ = 'programs'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    department_id = Column(BigInteger, ForeignKey('departments.id'), nullable=False)
    name = Column(NVARCHAR(255), nullable=False)
    total_credits = Column(Integer)
    
    # Relationships
    department = relationship("Department", back_populates="programs")
    outcomes = relationship("ProgramOutcome", back_populates="program")
    syllabuses = relationship("Syllabus", back_populates="program")
</file>

<file path="infrastructure/models/program_outcome_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class ProgramOutcome(Base):
    __tablename__ = 'program_outcomes'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    program_id = Column(BigInteger, ForeignKey('programs.id'), nullable=False)
    code = Column(NVARCHAR(20))
    description = Column(UnicodeText)
    
    # Relationships
    program = relationship("Program", back_populates="outcomes")
    clo_mappings = relationship("CloPloMapping", back_populates="program_plo")
</file>

<file path="infrastructure/models/role_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class Role(Base):
    __tablename__ = 'roles'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    name = Column(NVARCHAR(50), unique=True, nullable=False)
    description = Column(NVARCHAR(255), nullable=True)
    
    # Relationships
    user_roles = relationship("UserRole", back_populates="role")
    workflow_transitions = relationship("WorkflowTransition", back_populates="allowed_role")
</file>

<file path="infrastructure/models/rubric_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class Rubric(Base):
    __tablename__ = 'rubrics'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    component_id = Column(BigInteger, ForeignKey('assessment_components.id', ondelete='CASCADE'), nullable=False)
    criteria = Column(UnicodeText, nullable=False)
    max_score = Column(DECIMAL(3, 1), nullable=False)
    description_level_pass = Column(UnicodeText)
    description_level_fail = Column(UnicodeText)
    
    # Relationships
    component = relationship("AssessmentComponent", back_populates="rubrics")
</file>

<file path="infrastructure/models/student_report_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class StudentReport(Base):
    __tablename__ = 'student_reports'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    syllabus_id = Column(BigInteger, ForeignKey('syllabuses.id'), nullable=False)
    student_id = Column(BigInteger, ForeignKey('users.id'), nullable=False)
    content = Column(UnicodeText, nullable=False)
    status = Column(NVARCHAR(20), default='PENDING')  # PENDING, RESOLVED, REJECTED
    admin_note = Column(UnicodeText)
    
    # Relationships
    syllabus = relationship("Syllabus", back_populates="student_reports")
    student = relationship("User")
</file>

<file path="infrastructure/models/student_subscription_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class StudentSubscription(Base):
    __tablename__ = 'student_subscriptions'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    student_id = Column(BigInteger, ForeignKey('users.id'), nullable=False)
    subject_id = Column(BigInteger, ForeignKey('subjects.id'), nullable=False)
    created_at = Column(DateTime, default=func.now())
    
    # Relationships
    student = relationship("User")
    subject = relationship("Subject", back_populates="student_subscriptions")
</file>

<file path="infrastructure/models/subject_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class Subject(Base):
    __tablename__ = 'subjects'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    department_id = Column(BigInteger, ForeignKey('departments.id'), nullable=False)
    code = Column(NVARCHAR(20), unique=True, nullable=False)
    name_vi = Column(NVARCHAR(255), nullable=False)
    name_en = Column(NVARCHAR(255), nullable=False)
    credits = Column(Integer, nullable=False)
    credit_theory = Column(DECIMAL(3, 1), default=0)
    credit_practice = Column(DECIMAL(3, 1), default=0)
    credit_self_study = Column(DECIMAL(3, 1), default=0)
    
    # Relationships
    department = relationship("Department", back_populates="subjects")
    syllabuses = relationship("Syllabus", back_populates="subject")
    subject_relationships = relationship("SubjectRelationship", 
                                        foreign_keys="SubjectRelationship.subject_id",
                                        back_populates="subject")
    related_subjects = relationship("SubjectRelationship",
                                   foreign_keys="SubjectRelationship.related_subject_id",
                                   back_populates="related_subject")
    student_subscriptions = relationship("StudentSubscription", back_populates="subject")
</file>

<file path="infrastructure/models/subject_relationship_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class SubjectRelationship(Base):
    __tablename__ = 'subject_relationships'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    subject_id = Column(BigInteger, ForeignKey('subjects.id'), nullable=False)
    related_subject_id = Column(BigInteger, ForeignKey('subjects.id'), nullable=False)
    type = Column(NVARCHAR(20), nullable=False)  # PREREQUISITE, COREQUISITE, PARALLEL
    
    # Relationships
    subject = relationship("Subject", foreign_keys=[subject_id], back_populates="subject_relationships")
    related_subject = relationship("Subject", foreign_keys=[related_subject_id], back_populates="related_subjects")
</file>

<file path="infrastructure/models/syllabus_clo_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class SyllabusClo(Base):
    __tablename__ = 'syllabus_clos'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    syllabus_id = Column(BigInteger, ForeignKey('syllabuses.id', ondelete='CASCADE'), nullable=False)
    code = Column(NVARCHAR(20), nullable=False)
    description = Column(UnicodeText, nullable=False)
    embedding_vector = Column(UnicodeText, nullable=True)  # JSON vector
    created_at = Column(DateTime, default=func.now())
    
    # Relationships
    syllabus = relationship("Syllabus", back_populates="clos")
    plo_mappings = relationship("CloPloMapping", back_populates="syllabus_clo", cascade="all, delete-orphan")
    assessment_clos = relationship("AssessmentClo", back_populates="syllabus_clo")
</file>

<file path="infrastructure/models/syllabus_comment_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class SyllabusComment(Base):
    __tablename__ = 'syllabus_comments'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    syllabus_id = Column(BigInteger, ForeignKey('syllabuses.id'), nullable=False)
    user_id = Column(BigInteger, ForeignKey('users.id'), nullable=False)
    content = Column(UnicodeText, nullable=False)
    parent_id = Column(BigInteger, ForeignKey('syllabus_comments.id'), nullable=True)
    is_resolved = Column(Boolean, default=False)
    created_at = Column(DateTime, default=func.now())
    
    # Relationships
    syllabus = relationship("Syllabus", back_populates="comments")
    user = relationship("User", back_populates="comments")
    parent = relationship("SyllabusComment", remote_side=[id], backref="replies")
</file>

<file path="infrastructure/models/syllabus_current_workflow.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class SyllabusCurrentWorkflow(Base):
    __tablename__ = 'syllabus_current_workflows'
    
    syllabus_id = Column(BigInteger, ForeignKey('syllabuses.id'), primary_key=True)
    current_state_id = Column(BigInteger, ForeignKey('workflow_states.id'), nullable=False)
    assigned_to_user_id = Column(BigInteger, ForeignKey('users.id'), nullable=True)
    due_date = Column(DateTime, nullable=True)
    updated_at = Column(DateTime, default=func.now())
    
    # Relationships
    syllabus = relationship("Syllabus", back_populates="current_workflow")
    current_state = relationship("WorkflowState", back_populates="current_workflows")
    assigned_to_user = relationship("User")
</file>

<file path="infrastructure/models/syllabus_material_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class SyllabusMaterial(Base):
    __tablename__ = 'syllabus_materials'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    syllabus_id = Column(BigInteger, ForeignKey('syllabuses.id', ondelete='CASCADE'), nullable=False)
    type = Column(NVARCHAR(50), nullable=False)  # MAIN, REFERENCE
    title = Column(NVARCHAR(555), nullable=False)
    author = Column(NVARCHAR(255))
    publisher = Column(NVARCHAR(255))
    published_year = Column(Integer)
    isbn = Column(NVARCHAR(50))
    url = Column(UnicodeText, nullable=True)
    
    # Relationships
    syllabus = relationship("Syllabus", back_populates="materials")
</file>

<file path="infrastructure/models/syllabus_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from sqlalchemy.dialects.mssql import NVARCHAR
from infrastructure.databases.base import Base

class Syllabus(Base):
    __tablename__ = 'syllabuses'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    subject_id = Column(BigInteger, ForeignKey('subjects.id'), nullable=False)
    program_id = Column(BigInteger, ForeignKey('programs.id'), nullable=False)
    academic_year_id = Column(BigInteger, ForeignKey('academic_years.id'), nullable=False)
    lecturer_id = Column(BigInteger, ForeignKey('users.id'), nullable=False)
    status = Column(NVARCHAR(20))  # DRAFT, PENDING, APPROVED
    version = Column(NVARCHAR(10))
    time_allocation = Column(UnicodeText)  # JSON
    prerequisites = Column(UnicodeText)
    publish_date = Column(DateTime)
    is_active = Column(Boolean)
    embedding_vector = Column(UnicodeText, nullable=True)  # JSON vector
    created_at = Column(DateTime, default=func.now())
    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())
    
    # Relationships
    subject = relationship("Subject", back_populates="syllabuses")
    program = relationship("Program", back_populates="syllabuses")
    academic_year = relationship("AcademicYear", back_populates="syllabuses")
    lecturer = relationship("User", back_populates="syllabuses")
    clos = relationship("SyllabusClo", back_populates="syllabus", cascade="all, delete-orphan")
    materials = relationship("SyllabusMaterial", back_populates="syllabus", cascade="all, delete-orphan")
    teaching_plans = relationship("TeachingPlan", back_populates="syllabus", cascade="all, delete-orphan")
    assessment_schemes = relationship("AssessmentScheme", back_populates="syllabus", cascade="all, delete-orphan")
    comments = relationship("SyllabusComment", back_populates="syllabus")
    workflow_logs = relationship("WorkflowLog", back_populates="syllabus")
    current_workflow = relationship("SyllabusCurrentWorkflow", back_populates="syllabus", uselist=False)
    student_reports = relationship("StudentReport", back_populates="syllabus")
    ai_audit_logs = relationship("AiAuditLog", back_populates="syllabus")
</file>

<file path="infrastructure/models/system_auditlog_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class SystemAuditLog(Base):
    __tablename__ = 'system_audit_logs'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    user_id = Column(BigInteger, ForeignKey('users.id'), nullable=True)
    action_type = Column(NVARCHAR(50), nullable=False)
    resource_target = Column(NVARCHAR(100))
    ip_address = Column(NVARCHAR(45))
    user_agent = Column(UnicodeText)
    details = Column(UnicodeText)
    created_at = Column(DateTime, default=func.now())
    
    # Relationships
    user = relationship("User")
</file>

<file path="infrastructure/models/system_setting_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from sqlalchemy.dialects.mssql import NVARCHAR
from infrastructure.databases.base import Base

class SystemSetting(Base):
    __tablename__ = 'system_settings'
    
    key = Column(NVARCHAR(50), primary_key=True)
    value = Column(UnicodeText, nullable=False)
    type = Column(NVARCHAR(20), default='STRING')
    description = Column(NVARCHAR(255), nullable=True)
</file>

<file path="infrastructure/models/teaching_plan_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class TeachingPlan(Base):
    __tablename__ = 'teaching_plans'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    syllabus_id = Column(BigInteger, ForeignKey('syllabuses.id', ondelete='CASCADE'), nullable=False)
    week = Column(Integer)
    topic = Column(UnicodeText)
    activity = Column(UnicodeText)
    assessment = Column(UnicodeText)
    
    # Relationships
    syllabus = relationship("Syllabus", back_populates="teaching_plans")
</file>

<file path="infrastructure/models/user_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
# IMPORT BASE CHUNG (QUAN TRỌNG)
from infrastructure.databases.base import Base

class User(Base):
    __tablename__ = 'users'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    department_id = Column(BigInteger, ForeignKey('departments.id'), nullable=True)
    username = Column(NVARCHAR(50), unique=True, nullable=False)
    email = Column(NVARCHAR(100), unique=True, nullable=False)
    password_hash = Column(NVARCHAR(255), nullable=False)
    full_name = Column(NVARCHAR(100), nullable=False)
    is_active = Column(Boolean, default=True)
    
    # SỬA LỖI VÒNG LẶP: Thêm use_alter=True
    avatar_file_id = Column(BigInteger, ForeignKey('files.id', use_alter=True, name='fk_user_avatar_file'), nullable=True)
    
    # Relationships
    department = relationship("Department", back_populates="users")
    
    # Lưu ý: Cập nhật tên relationship nếu file_model dùng tên class là File
    avatar_file = relationship("File", foreign_keys=[avatar_file_id])
    uploaded_files = relationship("File", back_populates="uploader", foreign_keys="File.uploader_id")
    
    roles = relationship("UserRole", back_populates="user")
    syllabuses = relationship("Syllabus", back_populates="lecturer")
    comments = relationship("SyllabusComment", back_populates="user")
    notifications = relationship("Notification", back_populates="user")
    workflow_logs = relationship("WorkflowLog", back_populates="actor")
</file>

<file path="infrastructure/models/user_role_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class UserRole(Base):
    __tablename__ = 'user_roles'
    
    user_id = Column(BigInteger, ForeignKey('users.id'), primary_key=True)
    role_id = Column(BigInteger, ForeignKey('roles.id'), primary_key=True)
    
    # Relationships
    user = relationship("User", back_populates="roles")
    role = relationship("Role", back_populates="user_roles")
</file>

<file path="infrastructure/models/workflow_log_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from sqlalchemy.dialects.mssql import NVARCHAR
from infrastructure.databases.base import Base


class WorkflowLog(Base):
    __tablename__ = 'workflow_logs'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    syllabus_id = Column(BigInteger, ForeignKey('syllabuses.id'), nullable=False)
    actor_id = Column(BigInteger, ForeignKey('users.id'), nullable=False)
    action = Column(NVARCHAR(50))  # SUBMIT, APPROVE, REJECT
    from_status = Column(NVARCHAR(50))
    to_status = Column(NVARCHAR(50))
    comment = Column(UnicodeText)
    created_at = Column(DateTime, default=func.now())
    
    # Relationships
    syllabus = relationship("Syllabus", back_populates="workflow_logs")
    actor = relationship("User", back_populates="workflow_logs")
</file>

<file path="infrastructure/models/workflow_state_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class WorkflowState(Base):
    __tablename__ = 'workflow_states'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    code = Column(NVARCHAR(50), unique=True, nullable=False)
    name = Column(NVARCHAR(100), nullable=False)
    color = Column(NVARCHAR(20))
    is_final = Column(Boolean, default=False)
    
    # Relationships
    transitions_from = relationship("WorkflowTransition", 
                                   foreign_keys="WorkflowTransition.from_state_id",
                                   back_populates="from_state")
    transitions_to = relationship("WorkflowTransition",
                                 foreign_keys="WorkflowTransition.to_state_id",
                                 back_populates="to_state")
    current_workflows = relationship("SyllabusCurrentWorkflow", back_populates="current_state")
</file>

<file path="infrastructure/models/workflow_transition_model.py">
from datetime import datetime
from sqlalchemy import (
    Column, BigInteger, String, Integer, Date, DateTime, Boolean,
    ForeignKey, UnicodeText, DECIMAL, CheckConstraint, UniqueConstraint
)
from sqlalchemy.dialects.mssql import NVARCHAR
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from infrastructure.databases.base import Base

class WorkflowTransition(Base):
    __tablename__ = 'workflow_transitions'
    
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    from_state_id = Column(BigInteger, ForeignKey('workflow_states.id'), nullable=False)
    to_state_id = Column(BigInteger, ForeignKey('workflow_states.id'), nullable=False)
    allowed_role_id = Column(BigInteger, ForeignKey('roles.id'), nullable=False)
    action_name = Column(NVARCHAR(50))
    
    # Relationships
    from_state = relationship("WorkflowState", foreign_keys=[from_state_id], back_populates="transitions_from")
    to_state = relationship("WorkflowState", foreign_keys=[to_state_id], back_populates="transitions_to")
    allowed_role = relationship("Role", back_populates="workflow_transitions")
</file>

<file path="infrastructure/repositories/academic_year_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.academic_year_model import AcademicYear

class AcademicYearRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_all(self) -> List[AcademicYear]:
        return self.session.query(AcademicYear).all()

    def get_by_id(self, id: int) -> Optional[AcademicYear]:
        return self.session.query(AcademicYear).filter_by(id=id).first()

    def create(self, data: dict) -> AcademicYear:
        ay = AcademicYear(**data)
        self.session.add(ay)
        self.session.commit()
        self.session.refresh(ay)
        return ay

    def update(self, id: int, data: dict) -> Optional[AcademicYear]:
        ay = self.get_by_id(id)
        if not ay:
            return None
        for key, value in data.items():
            if hasattr(ay, key):
                setattr(ay, key, value)
        self.session.commit()
        self.session.refresh(ay)
        return ay

    def delete(self, id: int) -> bool:
        ay = self.get_by_id(id)
        if not ay:
            return False
        self.session.delete(ay)
        self.session.commit()
        return True
</file>

<file path="infrastructure/repositories/ai_auditlog_repository.py">
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.ai_auditlog_model import AiAuditLog

class AiAuditLogRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def create(self, syllabus_id: int, action: str, input_tokens: int, output_tokens: int):
        log = AiAuditLog(syllabus_id=syllabus_id, action=action, input_tokens=input_tokens, output_tokens=output_tokens)
        self.session.add(log)
        self.session.commit()
        return log
</file>

<file path="infrastructure/repositories/assessment_clo_repository.py">
from typing import List
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.assessment_clo_model import AssessmentClo
from infrastructure.models.syllabus_clo_model import SyllabusClo

class AssessmentCloRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def add_mapping(self, component_id: int, syllabus_clo_id: int) -> AssessmentClo:
        mapping = AssessmentClo(assessment_component_id=component_id, syllabus_clo_id=syllabus_clo_id)
        self.session.add(mapping)
        self.session.commit()
        return mapping

    def remove_mapping(self, component_id: int, syllabus_clo_id: int) -> bool:
        mapping = self.session.query(AssessmentClo).filter_by(assessment_component_id=component_id, syllabus_clo_id=syllabus_clo_id).first()
        if not mapping:
            return False
        self.session.delete(mapping)
        self.session.commit()
        return True

    def get_clos_by_component(self, component_id: int) -> List[SyllabusClo]:
        mappings = self.session.query(AssessmentClo).filter_by(assessment_component_id=component_id).all()
        return [m.syllabus_clo for m in mappings]
</file>

<file path="infrastructure/repositories/assessment_component_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.assessment_component_model import AssessmentComponent

class AssessmentComponentRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_by_id(self, id: int) -> Optional[AssessmentComponent]:
        return self.session.query(AssessmentComponent).filter_by(id=id).first()

    def create(self, data: dict) -> AssessmentComponent:
        item = AssessmentComponent(**data)
        self.session.add(item)
        self.session.commit()
        self.session.refresh(item)
        return item

    def update(self, id: int, data: dict) -> Optional[AssessmentComponent]:
        item = self.get_by_id(id)
        if not item:
            return None
        for k, v in data.items():
            if hasattr(item, k):
                setattr(item, k, v)
        self.session.commit()
        self.session.refresh(item)
        return item

    def delete(self, id: int) -> bool:
        item = self.get_by_id(id)
        if not item:
            return False
        self.session.delete(item)
        self.session.commit()
        return True
</file>

<file path="infrastructure/repositories/assessment_scheme_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session, joinedload
from infrastructure.databases.mssql import session
from infrastructure.models.assessment_scheme_model import AssessmentScheme

class AssessmentSchemeRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_all(self) -> List[AssessmentScheme]:
        return self.session.query(AssessmentScheme).all()

    def get_by_id(self, id: int) -> Optional[AssessmentScheme]:
        return self.session.query(AssessmentScheme).filter_by(id=id).first()

    def get_by_syllabus_id(self, syllabus_id: int) -> List[AssessmentScheme]:
        # Load components eagerly
        return self.session.query(AssessmentScheme).options(joinedload(AssessmentScheme.components)).filter_by(syllabus_id=syllabus_id).all()

    def create(self, data: dict) -> AssessmentScheme:
        s = AssessmentScheme(**data)
        self.session.add(s)
        self.session.commit()
        self.session.refresh(s)
        return s

    def update(self, id: int, data: dict) -> Optional[AssessmentScheme]:
        s = self.get_by_id(id)
        if not s:
            return None
        for k, v in data.items():
            if hasattr(s, k):
                setattr(s, k, v)
        self.session.commit()
        self.session.refresh(s)
        return s

    def delete(self, id: int) -> bool:
        s = self.get_by_id(id)
        if not s:
            return False
        self.session.delete(s)
        self.session.commit()
        return True
</file>

<file path="infrastructure/repositories/clo_plo_mapping_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.clo_plo_mapping_model import CloPloMapping

class CloPloMappingRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_by_id(self, id: int) -> Optional[CloPloMapping]:
        return self.session.query(CloPloMapping).filter_by(id=id).first()

    def get_by_syllabus_clo(self, syllabus_clo_id: int) -> List[CloPloMapping]:
        return self.session.query(CloPloMapping).filter_by(syllabus_clo_id=syllabus_clo_id).all()

    def create(self, data: dict) -> CloPloMapping:
        item = CloPloMapping(**data)
        self.session.add(item)
        self.session.commit()
        self.session.refresh(item)
        return item

    def delete(self, id: int) -> bool:
        item = self.get_by_id(id)
        if not item:
            return False
        self.session.delete(item)
        self.session.commit()
        return True
</file>

<file path="infrastructure/repositories/department_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.department_model import Department

class DepartmentRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_all(self) -> List[Department]:
        return self.session.query(Department).all()

    def get_by_id(self, id: int) -> Optional[Department]:
        return self.session.query(Department).filter_by(id=id).first()

    def create(self, data: dict) -> Department:
        department = Department(**data)
        self.session.add(department)
        self.session.commit()
        self.session.refresh(department)
        return department

    def update(self, id: int, data: dict) -> Optional[Department]:
        department = self.get_by_id(id)
        if not department:
            return None
        for key, value in data.items():
            if hasattr(department, key):
                setattr(department, key, value)
        self.session.commit()
        self.session.refresh(department)
        return department

    def delete(self, id: int) -> bool:
        department = self.get_by_id(id)
        if not department:
            return False
        self.session.delete(department)
        self.session.commit()
        return True
</file>

<file path="infrastructure/repositories/faculty_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.faculty_model import Faculty

class FacultyRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_all(self) -> List[Faculty]:
        return self.session.query(Faculty).all()

    def get_by_id(self, id: int) -> Optional[Faculty]:
        return self.session.query(Faculty).filter_by(id=id).first()

    def create(self, data: dict) -> Faculty:
        faculty = Faculty(**data)
        self.session.add(faculty)
        self.session.commit()
        self.session.refresh(faculty)
        return faculty

    def update(self, id: int, data: dict) -> Optional[Faculty]:
        faculty = self.get_by_id(id)
        if not faculty:
            return None
        for key, value in data.items():
            if hasattr(faculty, key):
                setattr(faculty, key, value)
        self.session.commit()
        self.session.refresh(faculty)
        return faculty

    def delete(self, id: int) -> bool:
        faculty = self.get_by_id(id)
        if not faculty:
            return False
        self.session.delete(faculty)
        self.session.commit()
        return True
</file>

<file path="infrastructure/repositories/file_repository.py">
from typing import Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.file_model import File

class FileRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_by_id(self, id: int) -> Optional[File]:
        return self.session.query(File).filter_by(id=id).first()

    def create(self, data: dict) -> File:
        file_record = File(**data)
        self.session.add(file_record)
        self.session.commit()
        self.session.refresh(file_record)
        return file_record

    def delete(self, id: int) -> bool:
        item = self.get_by_id(id)
        if not item:
            return False
        self.session.delete(item)
        self.session.commit()
        return True
</file>

<file path="infrastructure/repositories/notification_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.notification_model import Notification

class NotificationRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_by_user(self, user_id: int, limit: int = 20, unread_only: bool = False) -> List[Notification]:
        query = self.session.query(Notification).filter_by(user_id=user_id)
        if unread_only:
            query = query.filter_by(is_read=False)
        return query.order_by(Notification.created_at.desc()).limit(limit).all()

    def create(self, data: dict) -> Notification:
        item = Notification(**data)
        self.session.add(item)
        self.session.commit()
        self.session.refresh(item)
        return item

    def mark_as_read(self, id: int) -> bool:
        item = self.session.query(Notification).filter_by(id=id).first()
        if not item:
            return False
        item.is_read = True
        self.session.commit()
        return True

    def mark_all_as_read(self, user_id: int):
        self.session.query(Notification).filter_by(user_id=user_id, is_read=False).update({'is_read': True})
        self.session.commit()
</file>

<file path="infrastructure/repositories/program_outcome_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.program_outcome_model import ProgramOutcome

class ProgramOutcomeRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_by_id(self, id: int) -> Optional[ProgramOutcome]:
        return self.session.query(ProgramOutcome).filter_by(id=id).first()

    def get_by_program_id(self, program_id: int) -> List[ProgramOutcome]:
        return self.session.query(ProgramOutcome).filter_by(program_id=program_id).all()

    def create(self, data: dict) -> ProgramOutcome:
        item = ProgramOutcome(**data)
        self.session.add(item)
        self.session.commit()
        self.session.refresh(item)
        return item

    def update(self, id: int, data: dict) -> Optional[ProgramOutcome]:
        item = self.get_by_id(id)
        if not item:
            return None
        for k, v in data.items():
            if hasattr(item, k):
                setattr(item, k, v)
        self.session.commit()
        self.session.refresh(item)
        return item

    def delete(self, id: int) -> bool:
        item = self.get_by_id(id)
        if not item:
            return False
        self.session.delete(item)
        self.session.commit()
        return True
</file>

<file path="infrastructure/repositories/program_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.program_model import Program

class ProgramRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_all(self) -> List[Program]:
        return self.session.query(Program).all()

    def get_by_id(self, id: int) -> Optional[Program]:
        return self.session.query(Program).filter_by(id=id).first()

    def create(self, data: dict) -> Program:
        p = Program(**data)
        self.session.add(p)
        self.session.commit()
        self.session.refresh(p)
        return p

    def update(self, id: int, data: dict) -> Optional[Program]:
        p = self.get_by_id(id)
        if not p:
            return None
        for key, value in data.items():
            if hasattr(p, key):
                setattr(p, key, value)
        self.session.commit()
        self.session.refresh(p)
        return p

    def delete(self, id: int) -> bool:
        p = self.get_by_id(id)
        if not p:
            return False
        self.session.delete(p)
        self.session.commit()
        return True
</file>

<file path="infrastructure/repositories/role_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.role_model import Role

class RoleRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_all(self) -> List[Role]:
        return self.session.query(Role).all()

    def get_by_id(self, id: int) -> Optional[Role]:
        return self.session.query(Role).filter_by(id=id).first()

    def get_by_name(self, name: str) -> Optional[Role]:
        return self.session.query(Role).filter_by(name=name).first()

    def create(self, data: dict) -> Role:
        role = Role(**data)
        self.session.add(role)
        self.session.commit()
        self.session.refresh(role)
        return role

    def delete(self, id: int) -> bool:
        role = self.get_by_id(id)
        if not role:
            return False
        self.session.delete(role)
        self.session.commit()
        return True
</file>

<file path="infrastructure/repositories/rubric_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.rubric_model import Rubric

class RubricRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_by_id(self, id: int) -> Optional[Rubric]:
        return self.session.query(Rubric).filter_by(id=id).first()

    def get_by_component_id(self, component_id: int) -> List[Rubric]:
        return self.session.query(Rubric).filter_by(component_id=component_id).all()

    def create(self, data: dict) -> Rubric:
        item = Rubric(**data)
        self.session.add(item)
        self.session.commit()
        self.session.refresh(item)
        return item

    def update(self, id: int, data: dict) -> Optional[Rubric]:
        item = self.get_by_id(id)
        if not item:
            return None
        for k, v in data.items():
            if hasattr(item, k):
                setattr(item, k, v)
        self.session.commit()
        self.session.refresh(item)
        return item

    def delete(self, id: int) -> bool:
        item = self.get_by_id(id)
        if not item:
            return False
        self.session.delete(item)
        self.session.commit()
        return True
</file>

<file path="infrastructure/repositories/student_report_repository.py">
from typing import List
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.student_report_model import StudentReport

class StudentReportRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def create(self, data: dict) -> StudentReport:
        item = StudentReport(**data)
        self.session.add(item)
        self.session.commit()
        self.session.refresh(item)
        return item

    def get_all(self) -> List[StudentReport]:
        return self.session.query(StudentReport).all()

    def update_status(self, id: int, status: str, admin_note: str = None):
        item = self.session.query(StudentReport).filter_by(id=id).first()
        if item:
            item.status = status
            if admin_note: item.admin_note = admin_note
            self.session.commit()
            self.session.refresh(item)
        return item
</file>

<file path="infrastructure/repositories/student_subscription_repository.py">
from typing import List
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.student_subscription_model import StudentSubscription

class StudentSubscriptionRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def create(self, user_id: int, subject_id: int):
        # Check exists
        exists = self.session.query(StudentSubscription).filter_by(student_id=user_id, subject_id=subject_id).first()
        if exists: return exists
        
        item = StudentSubscription(student_id=user_id, subject_id=subject_id)
        self.session.add(item)
        self.session.commit()
        return item

    def delete(self, user_id: int, subject_id: int):
        item = self.session.query(StudentSubscription).filter_by(student_id=user_id, subject_id=subject_id).first()
        if item:
            self.session.delete(item)
            self.session.commit()
            return True
        return False

    def get_by_student(self, user_id: int) -> List[StudentSubscription]:
        return self.session.query(StudentSubscription).filter_by(student_id=user_id).all()
</file>

<file path="infrastructure/repositories/subject_relationship_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.subject_relationship_model import SubjectRelationship

class SubjectRelationshipRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_by_id(self, id: int) -> Optional[SubjectRelationship]:
        return self.session.query(SubjectRelationship).filter_by(id=id).first()

    def get_by_subject(self, subject_id: int) -> List[SubjectRelationship]:
        return self.session.query(SubjectRelationship).filter_by(subject_id=subject_id).all()

    def create(self, data: dict) -> SubjectRelationship:
        item = SubjectRelationship(**data)
        self.session.add(item)
        self.session.commit()
        self.session.refresh(item)
        return item

    def delete(self, id: int) -> bool:
        item = self.get_by_id(id)
        if not item:
            return False
        self.session.delete(item)
        self.session.commit()
        return True
</file>

<file path="infrastructure/repositories/subject_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.subject_model import Subject

class SubjectRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_all(self) -> List[Subject]:
        return self.session.query(Subject).all()

    def get_by_id(self, id: int) -> Optional[Subject]:
        return self.session.query(Subject).filter_by(id=id).first()

    def create(self, data: dict) -> Subject:
        subject = Subject(**data)
        self.session.add(subject)
        self.session.commit()
        self.session.refresh(subject)
        return subject

    def update(self, id: int, data: dict) -> Optional[Subject]:
        subject = self.get_by_id(id)
        if not subject:
            return None
        for key, value in data.items():
            if hasattr(subject, key):
                setattr(subject, key, value)
        self.session.commit()
        self.session.refresh(subject)
        return subject

    def delete(self, id: int) -> bool:
        subject = self.get_by_id(id)
        if not subject:
            return False
        self.session.delete(subject)
        self.session.commit()
        return True
</file>

<file path="infrastructure/repositories/syllabus_clo_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.syllabus_clo_model import SyllabusClo

class SyllabusCloRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_all(self) -> List[SyllabusClo]:
        return self.session.query(SyllabusClo).all()

    def get_by_id(self, id: int) -> Optional[SyllabusClo]:
        return self.session.query(SyllabusClo).filter_by(id=id).first()

    def get_by_syllabus_id(self, syllabus_id: int) -> List[SyllabusClo]:
        return self.session.query(SyllabusClo).filter_by(syllabus_id=syllabus_id).all()

    def create(self, data: dict) -> SyllabusClo:
        item = SyllabusClo(**data)
        self.session.add(item)
        self.session.commit()
        self.session.refresh(item)
        return item

    def update(self, id: int, data: dict) -> Optional[SyllabusClo]:
        item = self.get_by_id(id)
        if not item:
            return None
        for k, v in data.items():
            if hasattr(item, k):
                setattr(item, k, v)
        self.session.commit()
        self.session.refresh(item)
        return item

    def delete(self, id: int) -> bool:
        item = self.get_by_id(id)
        if not item:
            return False
        self.session.delete(item)
        self.session.commit()
        return True
</file>

<file path="infrastructure/repositories/syllabus_comment_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.syllabus_comment_model import SyllabusComment

class SyllabusCommentRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_by_id(self, id: int) -> Optional[SyllabusComment]:
        return self.session.query(SyllabusComment).filter_by(id=id).first()

    def get_by_syllabus(self, syllabus_id: int) -> List[SyllabusComment]:
        return self.session.query(SyllabusComment).filter_by(syllabus_id=syllabus_id).order_by(SyllabusComment.created_at.asc()).all()

    def create(self, data: dict) -> SyllabusComment:
        item = SyllabusComment(**data)
        self.session.add(item)
        self.session.commit()
        self.session.refresh(item)
        return item

    def update(self, id: int, data: dict) -> Optional[SyllabusComment]:
        item = self.get_by_id(id)
        if not item:
            return None
        for k, v in data.items():
            if hasattr(item, k):
                setattr(item, k, v)
        self.session.commit()
        self.session.refresh(item)
        return item

    def delete(self, id: int) -> bool:
        item = self.get_by_id(id)
        if not item:
            return False
        self.session.delete(item)
        self.session.commit()
        return True
</file>

<file path="infrastructure/repositories/syllabus_material_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.syllabus_material_model import SyllabusMaterial

class SyllabusMaterialRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_all(self) -> List[SyllabusMaterial]:
        return self.session.query(SyllabusMaterial).all()

    def get_by_id(self, id: int) -> Optional[SyllabusMaterial]:
        return self.session.query(SyllabusMaterial).filter_by(id=id).first()

    def get_by_syllabus_id(self, syllabus_id: int) -> List[SyllabusMaterial]:
        return self.session.query(SyllabusMaterial).filter_by(syllabus_id=syllabus_id).all()

    def create(self, data: dict) -> SyllabusMaterial:
        item = SyllabusMaterial(**data)
        self.session.add(item)
        self.session.commit()
        self.session.refresh(item)
        return item

    def delete(self, id: int) -> bool:
        item = self.get_by_id(id)
        if not item:
            return False
        self.session.delete(item)
        self.session.commit()
        return True
</file>

<file path="infrastructure/repositories/syllabus_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session, joinedload
from sqlalchemy import func
from infrastructure.databases.mssql import session
from infrastructure.models.syllabus_model import Syllabus
from infrastructure.models.assessment_scheme_model import AssessmentScheme
from infrastructure.models.assessment_component_model import AssessmentComponent

class SyllabusRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_all(self) -> List[Syllabus]:
        # Eager load related entities to prevent N+1 queries
        return (self.session.query(Syllabus)
                .options(
                    joinedload(Syllabus.subject),
                    joinedload(Syllabus.program),
                    joinedload(Syllabus.academic_year),
                    joinedload(Syllabus.lecturer)
                )
                .all())
    
    def get_all_paginated(self, page: int, page_size: int):
        """
        Get paginated syllabuses with eager loading
        Returns: (items, total_count)
        """
        query = (self.session.query(Syllabus)
                .options(
                    joinedload(Syllabus.subject),
                    joinedload(Syllabus.program),
                    joinedload(Syllabus.academic_year),
                    joinedload(Syllabus.lecturer)
                )
                .order_by(Syllabus.created_at.desc()))
        
        total = query.count()
        offset = (page - 1) * page_size
        items = query.offset(offset).limit(page_size).all()
        
        return items, total

    def get_by_id(self, id: int) -> Optional[Syllabus]:
        return (self.session.query(Syllabus)
                .options(
                    joinedload(Syllabus.subject),
                    joinedload(Syllabus.program),
                    joinedload(Syllabus.academic_year),
                    joinedload(Syllabus.lecturer)
                )
                .filter_by(id=id)
                .first())

    def get_by_subject_id(self, subject_id: int) -> List[Syllabus]:
        return (self.session.query(Syllabus)
                .options(
                    joinedload(Syllabus.subject),
                    joinedload(Syllabus.program),
                    joinedload(Syllabus.academic_year),
                    joinedload(Syllabus.lecturer)
                )
                .filter_by(subject_id=subject_id)
                .all())

    def get_details(self, id: int) -> Optional[Syllabus]:
        # Eagerly load related collections and nested components->rubrics
        return (
            self.session.query(Syllabus)
            .options(
                joinedload(Syllabus.clos),
                joinedload(Syllabus.materials),
                joinedload(Syllabus.teaching_plans),
                joinedload(Syllabus.assessment_schemes)
                    .joinedload(AssessmentScheme.components)
                    .joinedload(AssessmentComponent.rubrics),
            )
            .filter_by(id=id)
            .first()
        )

    def create(self, data: dict) -> Syllabus:
        s = Syllabus(**data)
        self.session.add(s)
        self.session.commit()
        self.session.refresh(s)
        return s

    def update(self, id: int, data: dict) -> Optional[Syllabus]:
        s = self.get_by_id(id)
        if not s:
            return None
        for key, value in data.items():
            if hasattr(s, key):
                setattr(s, key, value)
        self.session.commit()
        self.session.refresh(s)
        return s

    def delete(self, id: int) -> bool:
        s = self.get_by_id(id)
        if not s:
            return False
        self.session.delete(s)
        self.session.commit()
        return True
</file>

<file path="infrastructure/repositories/system_setting_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.system_setting_model import SystemSetting

class SystemSettingRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_all(self) -> List[SystemSetting]:
        return self.session.query(SystemSetting).all()

    def get_by_key(self, key: str) -> Optional[SystemSetting]:
        return self.session.query(SystemSetting).filter_by(key=key).first()

    def set_value(self, key: str, value: str, description: str = None, type: str = 'STRING') -> SystemSetting:
        setting = self.get_by_key(key)
        if setting:
            setting.value = value
            if description: setting.description = description
        else:
            setting = SystemSetting(key=key, value=value, type=type, description=description)
            self.session.add(setting)
        self.session.commit()
        self.session.refresh(setting)
        return setting
</file>

<file path="infrastructure/repositories/teaching_plan_repository.py">
from typing import List, Optional
from sqlalchemy.orm import Session
from infrastructure.databases.mssql import session
from infrastructure.models.teaching_plan_model import TeachingPlan

class TeachingPlanRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_by_id(self, id: int) -> Optional[TeachingPlan]:
        return self.session.query(TeachingPlan).filter_by(id=id).first()

    def get_by_syllabus_id(self, syllabus_id: int) -> List[TeachingPlan]:
        return self.session.query(TeachingPlan).filter_by(syllabus_id=syllabus_id).order_by(TeachingPlan.week).all()

    def create(self, data: dict) -> TeachingPlan:
        item = TeachingPlan(**data)
        self.session.add(item)
        self.session.commit()
        self.session.refresh(item)
        return item

    def update(self, id: int, data: dict) -> Optional[TeachingPlan]:
        item = self.get_by_id(id)
        if not item:
            return None
        for k, v in data.items():
            if hasattr(item, k):
                setattr(item, k, v)
        self.session.commit()
        self.session.refresh(item)
        return item

    def delete(self, id: int) -> bool:
        item = self.get_by_id(id)
        if not item:
            return False
        self.session.delete(item)
        self.session.commit()
        return True
</file>

<file path="infrastructure/repositories/user_repository.py">
from typing import List, Optional
from dotenv import load_dotenv
import os
from sqlalchemy.orm import Session
from infrastructure.databases import Base
from infrastructure.databases.mssql import session

# Import the User model
from infrastructure.models.user_model import User

load_dotenv()

class UserRepository:
    def __init__(self, session: Session = session):
        self.session = session

    def get_all(self) -> List[User]:
        return self.session.query(User).all()

    def get_by_username(self, username: str) -> Optional[User]:
        """Get user by username with input validation."""
        if not username or not isinstance(username, str):
            return None
        username = username.strip()
        if not username:
            return None
        return self.session.query(User).filter_by(username=username).first()

    def get_by_id(self, user_id: int) -> Optional[User]:
        return self.session.query(User).filter_by(id=user_id).first()

    def create(self, data: dict) -> User:
        user = User(**data)
        self.session.add(user)
        self.session.commit()
        self.session.refresh(user)
        return user

    def update(self, id: int, data: dict) -> Optional[User]:
        user = self.get_by_id(id)
        if not user:
            return None
        for key, value in data.items():
            if hasattr(user, key):
                setattr(user, key, value)
        self.session.commit()
        self.session.refresh(user)
        return user

    def delete(self, id: int) -> bool:
        user = self.get_by_id(id)
        if not user:
            return False
        self.session.delete(user)
        self.session.commit()
        return True
</file>

<file path="infrastructure/repositories/workflow_log_repository.py">
from typing import List
from infrastructure.models.workflow_log_model import WorkflowLog

class WorkflowLogRepository:
    def __init__(self, session):
        self.session = session

    def create(self, data: dict):
        wl = WorkflowLog(**data)
        self.session.add(wl)
        try:
            self.session.commit()
            self.session.refresh(wl)
            return wl
        except Exception:
            self.session.rollback()
            raise

    def get_by_syllabus_id(self, syllabus_id: int) -> List[WorkflowLog]:
        return self.session.query(WorkflowLog).filter_by(syllabus_id=syllabus_id).order_by(WorkflowLog.created_at.asc()).all()
</file>

<file path="infrastructure/services/...  # Services that use third party libraries or services (e.g. email service)">
# This file is intentionally left blank.
</file>

<file path="migrations">
# This directory contains database migration files.
</file>

<file path="requirements_additional.txt">
# Flask-Caching
flask-caching>=2.0.0

# Load testing
locust>=2.0.0

# Testing
pytest>=7.0.0
pytest-flask>=1.2.0
pytest-cov>=4.0.0
</file>

<file path="requirements.txt">
Flask>=2.0
Flask-Cors>=3.0
Flask-SQLAlchemy>=2.5
SQLAlchemy>=1.4
marshmallow>=3.0
pymssql>=2.2
python-dotenv>=0.21 
Flask-RESTX>=1.1.0 
flasgger
fastapi
apispec
apispec_webframeworks
flask-swagger-ui
dependency-injector>=4.0
PyJWT>=2.0
google-genai>=0.1
</file>

<file path="scripts/import_check.py">
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))  # apps/api/src
try:
    import services.syllabus_service as ss
    import services.ai_service as ai
    import api.schemas.syllabus_schema as sch
    import services.program_outcome_service as plo_svc
    import api.controllers.program_outcome_controller as plo_ctrl
    import services.file_service as file_svc
    import api.controllers.file_controller as file_ctrl
    import services.clo_plo_mapping_service as mapping_svc
    import api.controllers.clo_plo_mapping_controller as mapping_ctrl
    import services.subject_relationship_service as rel_svc
    import api.controllers.subject_relationship_controller as rel_ctrl
    import services.syllabus_comment_service as comment_svc
    import api.controllers.syllabus_comment_controller as comment_ctrl
    import services.notification_service as notif_svc
    import api.controllers.notification_controller as notif_ctrl
    import infrastructure.repositories.ai_auditlog_repository as audit_repo
    import services.system_setting_service as ss_svc
    import api.controllers.system_setting_controller as ss_ctrl
    import services.student_service as student_svc
    import api.controllers.student_controller as student_ctrl
    print('IMPORT_OK')
except Exception as e:
    print('IMPORT_FAIL', repr(e))
    raise
</file>

<file path="scripts/run_postgres.sh">
#!/bin/bash

# Function to check if PostgreSQL is running
is_postgres_running() {
    pg_isready -q
    return $?
}

# Start PostgreSQL if it's not already running
if ! is_postgres_running; then
    echo "PostgreSQL is not running. Starting it now..."
    pg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log start
else
    echo "PostgreSQL is already running."
fi

# Create the database if it doesn't exist
if ! psql -lqt | cut -d \| -f 1 | grep -qw dbname; then
    createdb dbname
fi
</file>

<file path="scripts/seed_users.py">
from dependency_container import Container
from datetime import date


def get_or_create(service, list_method_name, check_attr, check_value, create_method_name, create_data):
    list_method = getattr(service, list_method_name)
    for item in list_method():
        if getattr(item, check_attr) == check_value:
            return item
    create_method = getattr(service, create_method_name)
    return create_method(create_data)


def seed():
    container = Container()

    # Services
    role_service = container.role_service()
    user_service = container.user_service()
    faculty_service = container.faculty_service()
    department_service = container.department_service()
    academic_year_service = container.academic_year_service()
    program_service = container.program_service()
    subject_service = container.subject_service()
    syllabus_service = container.syllabus_service()
    syllabus_clo_service = container.syllabus_clo_service()
    syllabus_material_service = container.syllabus_material_service()

    # 1) Roles
    admin_role = role_service.get_by_name('ADMIN') or role_service.create_role({'name': 'ADMIN', 'description': 'ADMIN role'})
    print('✅  Role:', admin_role.name)
    lecturer_role = role_service.get_by_name('LECTURER') or role_service.create_role({'name': 'LECTURER', 'description': 'LECTURER role'})
    print('✅  Role:', lecturer_role.name)

    # 2) Users
    admin = user_service.get_by_username('admin')
    if not admin:
        admin = user_service.create_user({'username': 'admin', 'email': 'admin@example.com', 'full_name': 'Admin User', 'password': 'password123', 'is_active': True})
        print('✅  Created User: admin')
    else:
        print('✅  Found User: admin')

    lecturer = user_service.get_by_username('lecturer')
    if not lecturer:
        lecturer = user_service.create_user({'username': 'lecturer', 'email': 'lecturer@example.com', 'full_name': 'Lecturer User', 'password': 'password123', 'is_active': True})
        print('✅  Created User: lecturer')
    else:
        print('✅  Found User: lecturer')

    # Assign roles idempotently
    session = container.db_session()
    from infrastructure.models.user_role_model import UserRole

    def ensure_role(user, role):
        if not session.query(UserRole).filter_by(user_id=user.id, role_id=role.id).first():
            try:
                session.add(UserRole(user_id=user.id, role_id=role.id))
                session.commit()
                print(f"✅  Assigned role {role.name} to user {user.username}")
            except Exception:
                session.rollback()

    ensure_role(admin, admin_role)
    ensure_role(lecturer, lecturer_role)

    # 3) Faculty & Department
    faculty = get_or_create(faculty_service, 'list_faculties', 'code', 'FIT', 'create_faculty', {'code': 'FIT', 'name': 'Faculty of Information Technology'})
    print(f"✅  Faculty: {faculty.code} - {faculty.name}")

    department = None
    # department needs faculty_id
    for d in department_service.list_departments():
        if d.code == 'SE' and d.faculty_id == faculty.id:
            department = d
            break
    if not department:
        department = department_service.create_department({'faculty_id': faculty.id, 'code': 'SE', 'name': 'Software Engineering'})
        print('✅  Created Department: SE')
    else:
        print('✅  Found Department: SE')

    # 4) Academic Year, Program, Subject
    academic_year = get_or_create(academic_year_service, 'list_academic_years', 'code', '2025-2026', 'create_academic_year', {'code': '2025-2026', 'start_date': date(2025,9,1), 'end_date': date(2026,6,30)})
    print(f"✅  AcademicYear: {academic_year.code}")

    program = get_or_create(program_service, 'list_programs', 'name', 'Software Engineering K18', 'create_program', {'department_id': department.id, 'name': 'Software Engineering K18', 'total_credits': 120})
    print(f"✅  Program: {program.name}")

    subject = None
    for s in subject_service.list_subjects():
        if s.code == 'SWT301' and s.department_id == department.id:
            subject = s
            break
    if not subject:
        subject = subject_service.create_subject({'department_id': department.id, 'code': 'SWT301', 'name_vi': 'Giới thiệu Kỹ thuật Phần mềm', 'name_en': 'Introduction to Software Engineering', 'credits': 3})
        print('✅  Created Subject: SWT301')
    else:
        print('✅  Found Subject: SWT301')

    # 5) Syllabus
    syllabus = None
    for sy in syllabus_service.list_syllabuses():
        if sy.subject_id == subject.id and sy.program_id == program.id and sy.academic_year_id == academic_year.id:
            syllabus = sy
            break
    if not syllabus:
        syllabus = syllabus_service.create_syllabus({'subject_id': subject.id, 'program_id': program.id, 'academic_year_id': academic_year.id, 'lecturer_id': lecturer.id, 'version': '1.0'})
        print(f"✅  Created Syllabus ID: {syllabus.id}")
    else:
        print(f"✅  Found Syllabus ID: {syllabus.id}")

    # 6) Syllabus Details - CLOs
    existing_clos = {c.code for c in syllabus_clo_service.get_by_syllabus(syllabus.id)}
    clos_to_add = [
        {'code': 'CLO1', 'description': 'Explain software lifecycle.'},
        {'code': 'CLO2', 'description': 'Apply software requirements engineering.'},
        {'code': 'CLO3', 'description': 'Design basic software architecture.'},
    ]
    for clo in clos_to_add:
        if clo['code'] not in existing_clos:
            item = syllabus_clo_service.create_clo({'syllabus_id': syllabus.id, **clo})
            print(f"✅  Added CLO: {item.code}")
        else:
            print(f"✅  CLO exists: {clo['code']}")

    # Materials
    existing_mats = {m.title for m in syllabus_material_service.get_by_syllabus(syllabus.id)}
    mats_to_add = [
        {'type': 'MAIN', 'title': 'Software Engineering (Textbook)', 'author': 'Ian Sommerville', 'publisher': 'Pearson', 'isbn': '1234567890', 'syllabus_id': syllabus.id},
        {'type': 'REFERENCE', 'title': 'Design Patterns', 'author': 'Gamma et al.', 'publisher': 'Addison-Wesley', 'isbn': '0987654321', 'syllabus_id': syllabus.id},
    ]
    for mat in mats_to_add:
        if mat['title'] not in existing_mats:
            item = syllabus_material_service.create_material(mat)
            print(f"✅  Added Material: {item.title}")
        else:
            print(f"✅  Material exists: {mat['title']}")

    # Teaching Plans
    teaching_plan_service = container.teaching_plan_service()
    existing_weeks = {p.week for p in teaching_plan_service.list_plans_for_syllabus(syllabus.id)}
    plans_to_add = [
        {'week': 1, 'topic': 'Introduction to Software Engineering', 'activity': 'Lecture', 'assessment': 'Quiz', 'syllabus_id': syllabus.id},
        {'week': 2, 'topic': 'Software Process Models', 'activity': 'Lecture', 'assessment': 'Assignment 1', 'syllabus_id': syllabus.id},
        {'week': 3, 'topic': 'Requirements Engineering', 'activity': 'Lecture', 'assessment': 'Assignment 2', 'syllabus_id': syllabus.id},
    ]
    for plan in plans_to_add:
        if plan['week'] not in existing_weeks:
            item = teaching_plan_service.create_teaching_plan(plan)
            print(f"✅  Added Teaching Plan Week: {item.week}")
        else:
            print(f"✅  Teaching Plan exists for week: {plan['week']}")

    # Assessments: Schemes, Components, Rubrics, CLO mappings
    assessment_scheme_service = container.assessment_scheme_service()
    assessment_component_service = container.assessment_component_service()
    rubric_service = container.rubric_service()
    assessment_clo_service = container.assessment_clo_service()

    existing_schemes = {s.name for s in assessment_scheme_service.list_schemes_for_syllabus(syllabus.id)}

    # Example scheme: Midterm
    if 'Midterm' not in existing_schemes:
        scheme = assessment_scheme_service.create_scheme({'syllabus_id': syllabus.id, 'name': 'Midterm', 'weight': 30.0})
        print(f"✅  Created Assessment Scheme: {scheme.name}")
        comp = assessment_component_service.create_component({'scheme_id': scheme.id, 'name': 'Midterm Exam', 'weight': 30.0})
        print(f"✅  Created Assessment Component: {comp.name}")
        rubric = rubric_service.create_rubric({'component_id': comp.id, 'criteria': 'Comprehensive exam', 'max_score': 100})
        print(f"✅  Created Rubric for component: {rubric.criteria}")
        # Map to CLO1 if exists
        clo1 = None
        for c in syllabus_clo_service.get_by_syllabus(syllabus.id):
            if c.code == 'CLO1':
                clo1 = c
                break
        if clo1:
            assessment_clo_service.add_mapping(comp.id, clo1.id)
            print(f"✅  Mapped component {comp.name} to CLO {clo1.code}")
    else:
        print('✅  Midterm scheme exists')

    print('\n✅  Seeding complete!')


if __name__ == '__main__':
    seed()
</file>

<file path="SDM-workspace.code-workspace">
{
	"folders": [
		{
			"path": ".."
		},
		{
			"path": "../../FE_SDM"
		}
	]
}
</file>

<file path="services/...  # Services for interacting with the domain (business logic)">
# This file is intentionally left blank.
</file>

<file path="services/academic_year_service.py">
from typing import List, Optional
from infrastructure.repositories.academic_year_repository import AcademicYearRepository

class AcademicYearService:
    def __init__(self, repository: AcademicYearRepository):
        self.repository = repository

    def list_academic_years(self) -> List:
        return self.repository.get_all()

    def get_academic_year(self, id: int):
        return self.repository.get_by_id(id)

    def create_academic_year(self, data: dict):
        return self.repository.create(data)

    def update_academic_year(self, id: int, data: dict):
        return self.repository.update(id, data)

    def delete_academic_year(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="services/ai_service.py">
import os
import json
from datetime import datetime

# Prefer the new `google-genai` package (import path: `google.genai` via `from google import genai`).
# Fall back to legacy `google.generativeai` if needed for compatibility.
try:
    # New package (preferred)
    from google import genai
    _NEW_GENAI = True
except Exception:
    try:
        # Legacy package
        import google.generativeai as genai
        _NEW_GENAI = False
    except Exception:
        genai = None
        _NEW_GENAI = False

class AiService:
    def __init__(self, api_key: str = None, audit_repository=None):
        self.api_key = api_key or os.getenv('GEMINI_API_KEY')
        self.audit_repository = audit_repository

    def _log_usage(self, syllabus_id, action, in_tok, out_tok):
        if self.audit_repository and syllabus_id:
            try:
                self.audit_repository.create(syllabus_id, action, in_tok, out_tok)
            except Exception as e:
                print(f'Failed to log AI usage: {e}')

    def generate(self, subject_name: str, syllabus_id: int = None):
        if not self.api_key:
            return {"error": "Chưa cấu hình GEMINI_API_KEY"}

        if genai is None:
            return {"error": "No generative AI client installed (install google-genai)"}

        # Strict Template
        json_template = {
            "subject_name_vi": subject_name,
            "subject_name_en": "...",
            "credits": 3,
            "time_allocation": { "theory": 30, "practice": 30, "self_study": 90 },
            "description": "...",
            "clos": [
                { "code": "CLO1", "description": "..." }
            ],
            "materials": [
                { "type": "MAIN", "title": "...", "author": "...", "publisher": "...", "isbn": "..." }
            ],
            "teaching_plans": [
                { "week": 1, "topic": "...", "activity": "...", "assessment": "..." }
            ],
            "assessment_schemes": [
                { 
                    "name": "Midterm", "weight": 50, 
                    "components": [
                        { "name": "Exam 1", "weight": 100, "rubrics": [{"criteria": "...", "max_score": 10}] }
                    ] 
                }
            ]
        }

        prompt = f"""
        You are a curriculum expert. Create a syllabus for: "{subject_name}".
        OUTPUT REQUIREMENT: Return ONLY valid raw JSON. No markdown, no explanations.
        The JSON structure MUST match this template exactly:
        {json.dumps(json_template, ensure_ascii=False)}
        """

        try:
            if _NEW_GENAI:
                # New `google-genai` client APIs can vary by version. Try several common interfaces defensively.
                # Some versions provide a module-level `configure` and helpers; others provide a `Client` class.
                if hasattr(genai, "configure"):
                    try:
                        genai.configure(api_key=self.api_key)
                    except Exception:
                        # Some versions accept different config methods — ignore and continue to client creation
                        pass

                resp_text = None

                # Preferred: Client.generate_text(...) pattern
                if hasattr(genai, "Client"):
                    client = genai.Client()
                    response = client.generate_text(model="gemini-2.5-flash", input=prompt)
                    resp_text = getattr(response, "text", None)
                    if not resp_text and getattr(response, "candidates", None):
                        candidates = getattr(response, "candidates", [])
                        if candidates:
                            resp_text = getattr(candidates[0], "output", None) or getattr(candidates[0], "content", None)

                # Fallback: module-level generate_text
                if resp_text is None and hasattr(genai, "generate_text"):
                    response = genai.generate_text(model="gemini-2.5-flash", input=prompt)
                    resp_text = getattr(response, "text", None)
                    if not resp_text and getattr(response, "candidates", None):
                        candidates = getattr(response, "candidates", [])
                        if candidates:
                            resp_text = getattr(candidates[0], "output", None) or getattr(candidates[0], "content", None)

                # Last resort: string conversion
                if resp_text is None:
                    resp_text = str(response)

            else:
                # Legacy package behavior
                genai.configure(api_key=self.api_key)
                model = genai.GenerativeModel('gemini-2.5-flash')
                response = model.generate_content(prompt)
                resp_text = getattr(response, "text", "")

            clean_text = resp_text.replace("```json", "").replace("```", "").strip()
            # Simple token estimation (fallback if client does not provide usage)
            try:
                input_tokens = max(0, len(prompt.split()))
                output_tokens = max(0, len(clean_text.split()))
            except Exception:
                input_tokens = 0
                output_tokens = 0

            # Log usage if syllabus_id provided
            self._log_usage(syllabus_id, 'GENERATE', input_tokens, output_tokens)

            return json.loads(clean_text)
        except Exception as e:
            # Attempt to log error usage with zero tokens (if applicable)
            try:
                self._log_usage(syllabus_id, 'ERROR', 0, 0)
            except Exception:
                pass
            return {"error": str(e)}
</file>

<file path="services/assessment_clo_service.py">
from typing import List
from infrastructure.repositories.assessment_clo_repository import AssessmentCloRepository

class AssessmentCloService:
    def __init__(self, repository: AssessmentCloRepository, component_repository=None, syllabus_clo_repository=None, assessment_scheme_repository=None):
        self.repository = repository
        self.component_repository = component_repository
        self.syllabus_clo_repository = syllabus_clo_repository
        self.assessment_scheme_repository = assessment_scheme_repository

    def get_clos_for_component(self, component_id: int) -> List:
        return self.repository.get_clos_by_component(component_id)

    def add_mapping(self, component_id: int, syllabus_clo_id: int):
        component = self.component_repository.get_by_id(component_id)
        if not component:
            raise ValueError('Invalid component_id')
        syllabus_clo = self.syllabus_clo_repository.get_by_id(syllabus_clo_id)
        if not syllabus_clo:
            raise ValueError('Invalid syllabus_clo_id')

        # Determine the syllabus id for the component (via scheme relationship or scheme repository)
        comp_syllabus_id = None
        if getattr(component, 'scheme', None):
            comp_syllabus_id = component.scheme.syllabus_id
        elif hasattr(component, 'scheme_id'):
            if not self.assessment_scheme_repository:
                raise ValueError('Cannot determine component syllabus without assessment_scheme_repository')
            scheme = self.assessment_scheme_repository.get_by_id(component.scheme_id)
            if not scheme:
                raise ValueError('Invalid component: linked scheme not found')
            comp_syllabus_id = scheme.syllabus_id
        else:
            raise ValueError('Invalid component: cannot resolve related scheme')

        # Ensure both belong to the same syllabus
        if comp_syllabus_id != syllabus_clo.syllabus_id:
            raise ValueError('Cross-reference Error: Component and CLO must belong to the same Syllabus')

        return self.repository.add_mapping(component_id, syllabus_clo_id)

    def remove_mapping(self, component_id: int, syllabus_clo_id: int) -> bool:
        return self.repository.remove_mapping(component_id, syllabus_clo_id)
</file>

<file path="services/assessment_component_service.py">
from typing import Optional
from infrastructure.repositories.assessment_component_repository import AssessmentComponentRepository

class AssessmentComponentService:
    def __init__(self, repository: AssessmentComponentRepository, scheme_repository=None):
        self.repository = repository
        self.scheme_repository = scheme_repository

    def get_component(self, id: int):
        return self.repository.get_by_id(id)

    def create_component(self, data: dict):
        scheme_id = data.get('scheme_id')
        if not scheme_id or not self.scheme_repository.get_by_id(scheme_id):
            raise ValueError('Invalid scheme_id')
        return self.repository.create(data)

    def update_component(self, id: int, data: dict):
        return self.repository.update(id, data)

    def delete_component(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="services/assessment_scheme_service.py">
from typing import List, Optional
from infrastructure.repositories.assessment_scheme_repository import AssessmentSchemeRepository

class AssessmentSchemeService:
    def __init__(self, repository: AssessmentSchemeRepository, syllabus_repository=None):
        self.repository = repository
        self.syllabus_repository = syllabus_repository

    def list_schemes_for_syllabus(self, syllabus_id: int) -> List:
        return self.repository.get_by_syllabus_id(syllabus_id)

    def get_scheme(self, id: int):
        return self.repository.get_by_id(id)

    def create_scheme(self, data: dict):
        syllabus_id = data.get('syllabus_id')
        if not syllabus_id or not self.syllabus_repository.get_by_id(syllabus_id):
            raise ValueError('Invalid syllabus_id')
        return self.repository.create(data)

    def update_scheme(self, id: int, data: dict):
        return self.repository.update(id, data)

    def delete_scheme(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="services/clo_plo_mapping_service.py">
from typing import List
from infrastructure.repositories.clo_plo_mapping_repository import CloPloMappingRepository

class CloPloMappingService:
    def __init__(self, repository: CloPloMappingRepository, syllabus_clo_repository=None, program_outcome_repository=None):
        self.repository = repository
        self.syllabus_clo_repository = syllabus_clo_repository
        self.program_outcome_repository = program_outcome_repository

    def get_by_clo(self, clo_id: int) -> List:
        return self.repository.get_by_syllabus_clo(clo_id)

    def create_mapping(self, data: dict):
        clo_id = data.get('syllabus_clo_id')
        plo_id = data.get('program_plo_id')
        
        if not self.syllabus_clo_repository.get_by_id(clo_id):
            raise ValueError('Invalid syllabus_clo_id')
        if not self.program_outcome_repository.get_by_id(plo_id):
            raise ValueError('Invalid program_plo_id')
            
        return self.repository.create(data)

    def delete_mapping(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="services/department_service.py">
from typing import List, Optional
from infrastructure.repositories.department_repository import DepartmentRepository

class DepartmentService:
    def __init__(self, repository: DepartmentRepository):
        self.repository = repository

    def list_departments(self) -> List:
        return self.repository.get_all()

    def get_department(self, id: int):
        return self.repository.get_by_id(id)

    def create_department(self, data: dict):
        return self.repository.create(data)

    def update_department(self, id: int, data: dict):
        return self.repository.update(id, data)

    def delete_department(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="services/faculty_service.py">
from typing import List, Optional
from infrastructure.repositories.faculty_repository import FacultyRepository

class FacultyService:
    def __init__(self, repository: FacultyRepository):
        self.repository = repository

    def list_faculties(self) -> List:
        return self.repository.get_all()

    def get_faculty(self, id: int):
        return self.repository.get_by_id(id)

    def create_faculty(self, data: dict):
        return self.repository.create(data)

    def update_faculty(self, id: int, data: dict):
        return self.repository.update(id, data)

    def delete_faculty(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="services/file_service.py">
import os
import uuid
from werkzeug.utils import secure_filename
from infrastructure.repositories.file_repository import FileRepository

UPLOAD_FOLDER = 'static/uploads'
ALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif', 'doc', 'docx'}

class FileService:
    def __init__(self, repository: FileRepository):
        self.repository = repository
        if not os.path.exists(UPLOAD_FOLDER):
            os.makedirs(UPLOAD_FOLDER)

    def _allowed_file(self, filename):
        return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

    def upload_file(self, file_storage, uploader_id: int):
        if not file_storage or file_storage.filename == '':
            raise ValueError('No file selected')
        if not self._allowed_file(file_storage.filename):
            raise ValueError('File type not allowed')

        filename = secure_filename(file_storage.filename)
        unique_name = f"{uuid.uuid4()}_{filename}"
        file_path = os.path.join(UPLOAD_FOLDER, unique_name)
        
        # Save to disk
        file_storage.save(file_path)

        # Save to DB
        file_data = {
            'uploader_id': uploader_id,
            'file_name': filename,
            'file_path': file_path,
            'mime_type': file_storage.mimetype,
            'file_size': 0 # Optional: implement size check
        }
        return self.repository.create(file_data)
        
    def get_file(self, id: int):
        return self.repository.get_by_id(id)
</file>

<file path="services/notification_service.py">
from typing import List
from infrastructure.repositories.notification_repository import NotificationRepository

class NotificationService:
    def __init__(self, repository: NotificationRepository, user_repository=None):
        self.repository = repository
        self.user_repository = user_repository

    def get_user_notifications(self, user_id: int, unread_only: bool = False) -> List:
        return self.repository.get_by_user(user_id, unread_only=unread_only)

    def send_notification(self, user_id: int, title: str, message: str, link: str = None, type: str = 'SYSTEM'):
        if self.user_repository and not self.user_repository.get_by_id(user_id):
             raise ValueError('User not found')
        data = {
            'user_id': user_id,
            'title': title,
            'message': message,
            'link': link,
            'type': type,
            'is_read': False
        }
        return self.repository.create(data)

    def mark_read(self, id: int) -> bool:
        return self.repository.mark_as_read(id)

    def mark_all_read(self, user_id: int):
        return self.repository.mark_all_as_read(user_id)
</file>

<file path="services/program_outcome_service.py">
from typing import List
from infrastructure.repositories.program_outcome_repository import ProgramOutcomeRepository

class ProgramOutcomeService:
    def __init__(self, repository: ProgramOutcomeRepository, program_repository=None):
        self.repository = repository
        self.program_repository = program_repository

    def list_by_program(self, program_id: int) -> List:
        return self.repository.get_by_program_id(program_id)

    def create_plo(self, data: dict):
        program_id = data.get('program_id')
        if not program_id or not self.program_repository.get_by_id(program_id):
            raise ValueError('Invalid program_id')
        return self.repository.create(data)

    def update_plo(self, id: int, data: dict):
        return self.repository.update(id, data)

    def delete_plo(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="services/program_service.py">
from typing import List, Optional
from infrastructure.repositories.program_repository import ProgramRepository

class ProgramService:
    def __init__(self, repository: ProgramRepository):
        self.repository = repository

    def list_programs(self) -> List:
        return self.repository.get_all()

    def get_program(self, id: int):
        return self.repository.get_by_id(id)

    def create_program(self, data: dict):
        return self.repository.create(data)

    def update_program(self, id: int, data: dict):
        return self.repository.update(id, data)

    def delete_program(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="services/role_service.py">
from typing import List, Optional
from infrastructure.repositories.role_repository import RoleRepository

class RoleService:
    def __init__(self, repository: RoleRepository):
        self.repository = repository

    def list_roles(self) -> List:
        return self.repository.get_all()

    def get_role(self, id: int):
        return self.repository.get_by_id(id)

    def get_by_name(self, name: str):
        return self.repository.get_by_name(name)

    def create_role(self, data: dict):
        return self.repository.create(data)

    def delete_role(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="services/rubric_service.py">
from typing import List, Optional
from infrastructure.repositories.rubric_repository import RubricRepository

class RubricService:
    def __init__(self, repository: RubricRepository, component_repository=None):
        self.repository = repository
        self.component_repository = component_repository

    def list_rubrics_for_component(self, component_id: int) -> List:
        return self.repository.get_by_component_id(component_id)

    def get_rubric(self, id: int):
        return self.repository.get_by_id(id)

    def create_rubric(self, data: dict):
        component_id = data.get('component_id')
        if not component_id or not self.component_repository.get_by_id(component_id):
            raise ValueError('Invalid component_id')
        return self.repository.create(data)

    def update_rubric(self, id: int, data: dict):
        return self.repository.update(id, data)

    def delete_rubric(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="services/student_service.py">
from typing import List
from infrastructure.repositories.student_subscription_repository import StudentSubscriptionRepository
from infrastructure.repositories.student_report_repository import StudentReportRepository

class StudentService:
    def __init__(self, sub_repo: StudentSubscriptionRepository, report_repo: StudentReportRepository):
        self.sub_repo = sub_repo
        self.report_repo = report_repo

    def subscribe(self, user_id: int, subject_id: int):
        return self.sub_repo.create(user_id, subject_id)

    def unsubscribe(self, user_id: int, subject_id: int):
        return self.sub_repo.delete(user_id, subject_id)

    def get_subscriptions(self, user_id: int):
        return self.sub_repo.get_by_student(user_id)

    def report_syllabus(self, user_id: int, syllabus_id: int, content: str):
        return self.report_repo.create({'student_id': user_id, 'syllabus_id': syllabus_id, 'content': content})

    def list_reports(self):
        return self.report_repo.get_all()

    def resolve_report(self, id: int, status: str, note: str = None):
        return self.report_repo.update_status(id, status, note)
</file>

<file path="services/subject_relationship_service.py">
from typing import List
from infrastructure.repositories.subject_relationship_repository import SubjectRelationshipRepository

class SubjectRelationshipService:
    def __init__(self, repository: SubjectRelationshipRepository, subject_repository=None):
        self.repository = repository
        self.subject_repository = subject_repository

    def get_relationships(self, subject_id: int) -> List:
        return self.repository.get_by_subject(subject_id)

    def add_relationship(self, data: dict):
        subject_id = data.get('subject_id')
        related_id = data.get('related_subject_id')
        
        if subject_id == related_id:
            raise ValueError('Subject cannot be related to itself')
        
        if not self.subject_repository.get_by_id(subject_id):
            raise ValueError('Invalid subject_id')
        if not self.subject_repository.get_by_id(related_id):
            raise ValueError('Invalid related_subject_id')
            
        return self.repository.create(data)

    def remove_relationship(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="services/subject_service.py">
from typing import List, Optional
from infrastructure.repositories.subject_repository import SubjectRepository

class SubjectService:
    def __init__(self, repository: SubjectRepository):
        self.repository = repository

    def list_subjects(self) -> List:
        return self.repository.get_all()

    def get_subject(self, id: int):
        return self.repository.get_by_id(id)

    def create_subject(self, data: dict):
        return self.repository.create(data)

    def update_subject(self, id: int, data: dict):
        return self.repository.update(id, data)

    def delete_subject(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="services/syllabus_clo_service.py">
from typing import List, Optional
from infrastructure.repositories.syllabus_clo_repository import SyllabusCloRepository

class SyllabusCloService:
    def __init__(self, repository: SyllabusCloRepository, syllabus_repository=None):
        self.repository = repository
        self.syllabus_repository = syllabus_repository

    def list_clos(self) -> List:
        return self.repository.get_all()

    def get_clo(self, id: int):
        return self.repository.get_by_id(id)

    def get_by_syllabus(self, syllabus_id: int):
        return self.repository.get_by_syllabus_id(syllabus_id)

    def create_clo(self, data: dict):
        syllabus_id = data.get('syllabus_id')
        if not syllabus_id or not self.syllabus_repository.get_by_id(syllabus_id):
            raise ValueError('Invalid syllabus_id')
        return self.repository.create(data)

    def update_clo(self, id: int, data: dict):
        return self.repository.update(id, data)

    def delete_clo(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="services/syllabus_comment_service.py">
from typing import List
from infrastructure.repositories.syllabus_comment_repository import SyllabusCommentRepository

class SyllabusCommentService:
    def __init__(self, repository: SyllabusCommentRepository, syllabus_repository=None, user_repository=None):
        self.repository = repository
        self.syllabus_repository = syllabus_repository
        self.user_repository = user_repository

    def get_comments(self, syllabus_id: int) -> List:
        return self.repository.get_by_syllabus(syllabus_id)

    def add_comment(self, data: dict):
        syllabus_id = data.get('syllabus_id')
        user_id = data.get('user_id')
        
        if not self.syllabus_repository.get_by_id(syllabus_id):
            raise ValueError('Invalid syllabus_id')
        if not self.user_repository.get_by_id(user_id):
            raise ValueError('Invalid user_id')
            
        return self.repository.create(data)

    def resolve_comment(self, id: int):
        return self.repository.update(id, {'is_resolved': True})

    def delete_comment(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="services/syllabus_material_service.py">
from typing import List, Optional
from infrastructure.repositories.syllabus_material_repository import SyllabusMaterialRepository

class SyllabusMaterialService:
    def __init__(self, repository: SyllabusMaterialRepository, syllabus_repository=None):
        self.repository = repository
        self.syllabus_repository = syllabus_repository

    def list_materials(self) -> List:
        return self.repository.get_all()

    def get_material(self, id: int):
        return self.repository.get_by_id(id)

    def get_by_syllabus(self, syllabus_id: int):
        return self.repository.get_by_syllabus_id(syllabus_id)

    def create_material(self, data: dict):
        syllabus_id = data.get('syllabus_id')
        if not syllabus_id or not self.syllabus_repository.get_by_id(syllabus_id):
            raise ValueError('Invalid syllabus_id')
        return self.repository.create(data)

    def delete_material(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="services/syllabus_service.py">
from typing import List, Optional
from infrastructure.repositories.syllabus_repository import SyllabusRepository
from utils.logging_config import get_logger

logger = get_logger(__name__)

class SyllabusService:
    def __init__(self, repository: SyllabusRepository,
                 subject_repository=None,
                 program_repository=None,
                 academic_year_repository=None,
                 user_repository=None,
                 workflow_log_repository=None,
                 syllabus_clo_repository=None,
                 syllabus_material_repository=None,
                 teaching_plan_repository=None,
                 assessment_scheme_repository=None,
                 assessment_component_repository=None,
                 rubric_repository=None,
                 assessment_clo_repository=None):
        self.repository = repository
        self.subject_repository = subject_repository
        self.program_repository = program_repository
        self.academic_year_repository = academic_year_repository
        self.user_repository = user_repository
        self.workflow_log_repository = workflow_log_repository
        self.syllabus_clo_repository = syllabus_clo_repository
        self.syllabus_material_repository = syllabus_material_repository
        self.teaching_plan_repository = teaching_plan_repository
        self.assessment_scheme_repository = assessment_scheme_repository
        self.assessment_component_repository = assessment_component_repository
        self.rubric_repository = rubric_repository
        self.assessment_clo_repository = assessment_clo_repository

    def list_syllabuses(self) -> List:
        logger.info("Listing all syllabuses")
        try:
            result = self.repository.get_all()
            logger.info(f"Retrieved {len(result)} syllabuses")
            return result
        except Exception as e:
            logger.error(f"Error listing syllabuses: {str(e)}", exc_info=True)
            raise
    
    def list_syllabuses_paginated(self, page: int, page_size: int):
        """Get paginated list of syllabuses"""
        logger.info(f"Listing syllabuses - page {page}, size {page_size}")
        try:
            items, total = self.repository.get_all_paginated(page, page_size)
            logger.info(f"Retrieved {len(items)} of {total} syllabuses")
            return items, total
        except Exception as e:
            logger.error(f"Error listing paginated syllabuses: {str(e)}", exc_info=True)
            raise

    def get_syllabus(self, id: int):
        return self.repository.get_by_id(id)

    def get_syllabus_details(self, id: int):
        return self.repository.get_details(id)

    def get_by_subject(self, subject_id: int):
        return self.repository.get_by_subject_id(subject_id)

    def create_syllabus(self, data: dict):
        import json
        
        # Extract child data
        clos_data = data.pop('clos', [])
        materials_data = data.pop('materials', [])
        plans_data = data.pop('teaching_plans', [])
        schemes_data = data.pop('assessment_schemes', [])

        # Handle time_allocation (Dict -> JSON String)
        if 'time_allocation' in data and isinstance(data['time_allocation'], dict):
            data['time_allocation'] = json.dumps(data['time_allocation'])

        # Validate Foreign Keys
        subject_id = data.get('subject_id')
        if not subject_id or not self.subject_repository.get_by_id(subject_id):
            raise ValueError('Invalid subject_id')
        program_id = data.get('program_id')
        if not program_id or not self.program_repository.get_by_id(program_id):
            raise ValueError('Invalid program_id')
        academic_year_id = data.get('academic_year_id')
        if not academic_year_id or not self.academic_year_repository.get_by_id(academic_year_id):
            raise ValueError('Invalid academic_year_id')
        lecturer_id = data.get('lecturer_id')
        if not lecturer_id or not self.user_repository.get_by_id(lecturer_id):
            raise ValueError('Invalid lecturer_id')

        # Create Header
        data.setdefault('status', 'DRAFT')
        new_syllabus = self.repository.create(data)
        sid = new_syllabus.id

        # 1. Save CLOs
        if self.syllabus_clo_repository:
            for item in clos_data:
                item['syllabus_id'] = sid
                self.syllabus_clo_repository.create(item)

        # 2. Save Materials
        if self.syllabus_material_repository:
            for item in materials_data:
                item['syllabus_id'] = sid
                self.syllabus_material_repository.create(item)

        # 3. Save Teaching Plans
        if self.teaching_plan_repository:
            for item in plans_data:
                item['syllabus_id'] = sid
                self.teaching_plan_repository.create(item)

        # 4. Save Assessment Schemes (Nested)
        if self.assessment_scheme_repository:
            for scheme in schemes_data:
                components = scheme.pop('components', [])
                scheme['syllabus_id'] = sid
                new_scheme = self.assessment_scheme_repository.create(scheme)
                if self.assessment_component_repository:
                    for comp in components:
                        rubrics = comp.pop('rubrics', [])
                        comp['scheme_id'] = new_scheme.id
                        new_comp = self.assessment_component_repository.create(comp)
                        if self.rubric_repository:
                            for rub in rubrics:
                                rub['component_id'] = new_comp.id
                                self.rubric_repository.create(rub)

        return new_syllabus

    def update_syllabus(self, id: int, data: dict):
        # Check current status before allowing update
        s = self.repository.get_by_id(id)
        if not s:
            return None
        if s.status not in ('DRAFT', 'REJECTED'):
            raise ValueError(f"Cannot update syllabus in {s.status} status")
        return self.repository.update(id, data)

    def delete_syllabus(self, id: int) -> bool:
        return self.repository.delete(id)

    # Workflow methods
    def submit_syllabus(self, id: int, user_id: int):
        """Submit syllabus for evaluation. Can only submit from DRAFT or REJECTED status."""
        s = self.repository.get_by_id(id)
        if not s:
            return None
        
        current_status = (s.status or '').upper()
        # Only allow submission from DRAFT or REJECTED states
        valid_states = ('DRAFT', 'REJECTED')
        
        if current_status not in valid_states:
            raise ValueError(
                f'Cannot submit syllabus in {current_status} status. '
                f'Valid states for submission: {valid_states}'
            )
        
        from_status = s.status
        updated = self.repository.update(id, {'status': 'PENDING'})
        if self.workflow_log_repository:
            self.workflow_log_repository.create({
                'syllabus_id': id,
                'actor_id': user_id,
                'action': 'SUBMIT',
                'from_status': from_status,
                'to_status': 'PENDING',
                'comment': None
            })
        return updated

    def evaluate_syllabus(self, id: int, user_id: int, action: str, comment: Optional[str] = None):
        """Evaluate syllabus. Can only evaluate PENDING syllabuses."""
        s = self.repository.get_by_id(id)
        if not s:
            return None
        
        action = action.upper()
        if action not in ('APPROVE', 'REJECT'):
            raise ValueError(f'Invalid action: {action}. Must be APPROVE or REJECT')
        
        # Check current status
        if s.status != 'PENDING':
            raise ValueError(
                f'Can only evaluate PENDING syllabuses. Current status: {s.status}'
            )
        
        from_status = s.status
        if action == 'APPROVE':
            new_status = 'APPROVED'
        else:  # REJECT
            if not comment:
                raise ValueError('Comment is required when rejecting')
            new_status = 'DRAFT'
        
        updated = self.repository.update(id, {'status': new_status})
        if self.workflow_log_repository:
            self.workflow_log_repository.create({
                'syllabus_id': id,
                'actor_id': user_id,
                'action': action,
                'from_status': from_status,
                'to_status': new_status,
                'comment': comment
            })
        return updated

    def get_workflow_logs(self, syllabus_id: int):
        if not self.workflow_log_repository:
            return []
        return self.workflow_log_repository.get_by_syllabus_id(syllabus_id)
</file>

<file path="services/system_setting_service.py">
from typing import List, Optional
from infrastructure.repositories.system_setting_repository import SystemSettingRepository

class SystemSettingService:
    def __init__(self, repository: SystemSettingRepository):
        self.repository = repository

    def get_all_settings(self) -> List:
        return self.repository.get_all()

    def update_setting(self, key: str, value: str, description: str = None):
        return self.repository.set_value(key, value, description)
</file>

<file path="services/teaching_plan_service.py">
from typing import List, Optional
from infrastructure.repositories.teaching_plan_repository import TeachingPlanRepository

class TeachingPlanService:
    def __init__(self, repository: TeachingPlanRepository, syllabus_repository=None):
        self.repository = repository
        self.syllabus_repository = syllabus_repository

    def list_plans_for_syllabus(self, syllabus_id: int) -> List:
        return self.repository.get_by_syllabus_id(syllabus_id)

    def get_plan(self, id: int):
        return self.repository.get_by_id(id)

    def create_teaching_plan(self, data: dict):
        syllabus_id = data.get('syllabus_id')
        if not syllabus_id or not self.syllabus_repository.get_by_id(syllabus_id):
            raise ValueError('Invalid syllabus_id')
        return self.repository.create(data)

    def update_teaching_plan(self, id: int, data: dict):
        return self.repository.update(id, data)

    def delete_teaching_plan(self, id: int) -> bool:
        return self.repository.delete(id)
</file>

<file path="services/user_service.py">
from typing import List, Optional
from werkzeug.security import generate_password_hash, check_password_hash
from infrastructure.repositories.user_repository import UserRepository

class UserService:
    def __init__(self, repository: UserRepository):
        self.repository = repository

    def list_users(self) -> List:
        return self.repository.get_all()

    def get_user(self, id: int):
        return self.repository.get_by_id(id)

    def get_by_username(self, username: str):
        return self.repository.get_by_username(username)

    def create_user(self, data: dict):
        # Hash password before saving
        if 'password' in data:
            data['password_hash'] = generate_password_hash(data.pop('password'))
        return self.repository.create(data)

    def update_user(self, id: int, data: dict):
        if 'password' in data:
            data['password_hash'] = generate_password_hash(data.pop('password'))
        return self.repository.update(id, data)

    def delete_user(self, id: int) -> bool:
        return self.repository.delete(id)

    def authenticate(self, username: str, password: str):
        user = self.get_by_username(username)
        if not user:
            return None
        if not check_password_hash(user.password_hash, password):
            return None
        return user
</file>

<file path="swagger_config.json">
{
    "template": {
        "swagger": "2.0",
        "info": {
            "title": "Syllabus Management API",
            "description": "API for Syllabus Management (SMD)",
            "version": "1.0.0"
        },
        "basePath": "/",
        "schemes": [
            "http",
            "https"
        ],
        "consumes": [
            "application/json"
        ],
        "produces": [
            "application/json"
        ]
    },
    "swagger_config": {
        "headers": [],
        "specs": [
            {
                "endpoint": "apispec",
                "route": "/apispec.json"
            }
        ],
        "static_url_path": "/flasgger_static",
        "swagger_ui": true,
        "specs_route": "/docs"
    }
}
</file>

<file path="tests/test_file_service.py">
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))  # apps/api/src

import os
import tempfile
from services.file_service import FileService, UPLOAD_FOLDER

class StubFileStorage:
    def __init__(self, filename, content=b"data", mimetype='application/octet-stream'):
        self.filename = filename
        self._content = content
        self.mimetype = mimetype

    def save(self, path):
        with open(path, 'wb') as f:
            f.write(self._content)


class StubRepo:
    def __init__(self):
        self.created = None
    def create(self, data):
        self.created = data
        class Item:
            def __init__(self, d):
                self.__dict__.update(d)
        return Item(data)


def test_upload_file_saves_to_disk_and_db(tmp_path, monkeypatch):
    # Use a temp upload folder
    tmp_dir = tmp_path / 'uploads'
    monkeypatch.setattr('services.file_service.UPLOAD_FOLDER', str(tmp_dir))

    repo = StubRepo()
    svc = FileService(repository=repo)

    file_storage = StubFileStorage('test.txt', b'hello', 'text/plain')
    record = svc.upload_file(file_storage, uploader_id=5)

    # Ensure file saved on disk
    assert os.path.exists(record.file_path)
    assert repo.created['uploader_id'] == 5
    assert repo.created['file_name'] == 'test.txt'


def test_upload_rejects_bad_extension():
    repo = StubRepo()
    svc = FileService(repository=repo)
    file_storage = StubFileStorage('test.exe')
    try:
        svc.upload_file(file_storage, uploader_id=1)
        assert False, 'Should raise ValueError for disallowed extension'
    except ValueError:
        pass
</file>

<file path="tests/test_program_outcome_service.py">
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))  # apps/api/src

from services.program_outcome_service import ProgramOutcomeService

class StubRepo:
    def __init__(self):
        self.created = {}
    def create(self, data):
        self.created = data
        return data
    def update(self, id, data):
        return {'id': id, **data}
    def delete(self, id):
        return True

class StubProgramRepo:
    def __init__(self, exists=True):
        self.exists = exists
    def get_by_id(self, id):
        return {'id': id} if self.exists else None


def test_create_plo_requires_valid_program():
    repo = StubRepo()
    program_repo = StubProgramRepo(exists=False)
    svc = ProgramOutcomeService(repository=repo, program_repository=program_repo)
    try:
        svc.create_plo({'program_id': 1, 'code': 'PLO1', 'description': 'd'})
        assert False, 'Should have raised ValueError'
    except ValueError:
        pass

    program_repo = StubProgramRepo(exists=True)
    svc = ProgramOutcomeService(repository=repo, program_repository=program_repo)
    item = svc.create_plo({'program_id': 1, 'code': 'PLO1', 'description': 'd'})
    assert repo.created['code'] == 'PLO1'


def test_update_and_delete_delegates_to_repo():
    repo = StubRepo()
    svc = ProgramOutcomeService(repository=repo)
    updated = svc.update_plo(1, {'code': 'X'})
    assert updated['id'] == 1
    assert svc.delete_plo(1) is True
</file>

<file path="tests/test_smoke_imports.py">
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))  # apps/api/src

from dependency_container import Container
from services.syllabus_service import SyllabusService
from services.program_outcome_service import ProgramOutcomeService
from services.file_service import FileService


def test_container_has_services():
    c = Container()
    assert hasattr(c, 'syllabus_service')
    assert hasattr(c, 'program_outcome_service')
    assert hasattr(c, 'file_service')


def test_service_classes_importable():
    assert callable(SyllabusService)
    assert callable(ProgramOutcomeService)
    assert callable(FileService)
</file>

<file path="tests/test_syllabus_service.py">
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))  # apps/api/src

import json
from services.syllabus_service import SyllabusService


class StubRepo:
    def __init__(self):
        self.created = []

    def create(self, data):
        # simulate DB model with id and status
        class Item:
            pass
        item = Item()
        item.id = 123
        item.status = data.get('status', 'DRAFT')
        self.created.append(data)
        return item

    def get_by_id(self, id):
        return None


class StubFKRepo:
    def __init__(self, exists=True):
        self.exists = exists

    def get_by_id(self, id):
        return {'id': id} if self.exists else None


class StubChildRepo:
    def __init__(self):
        self.items = []

    def create(self, data):
        self.items.append(data)
        class Item:
            def __init__(self, data, id):
                self.__dict__.update(data)
                self.id = id
        return Item(data, len(self.items))


def test_create_syllabus_creates_child_entities_and_serializes_time_allocation():
    repo = StubRepo()
    subj = StubFKRepo(True)
    prog = StubFKRepo(True)
    ay = StubFKRepo(True)
    user = StubFKRepo(True)
    clo_repo = StubChildRepo()
    mat_repo = StubChildRepo()
    plan_repo = StubChildRepo()
    scheme_repo = StubChildRepo()
    comp_repo = StubChildRepo()
    rubric_repo = StubChildRepo()

    svc = SyllabusService(
        repository=repo,
        subject_repository=subj,
        program_repository=prog,
        academic_year_repository=ay,
        user_repository=user,
        syllabus_clo_repository=clo_repo,
        syllabus_material_repository=mat_repo,
        teaching_plan_repository=plan_repo,
        assessment_scheme_repository=scheme_repo,
        assessment_component_repository=comp_repo,
        rubric_repository=rubric_repo
    )

    payload = {
        'subject_id': 1,
        'program_id': 1,
        'academic_year_id': 1,
        'lecturer_id': 1,
        'time_allocation': {'theory': 10, 'practice': 20},
        'clos': [{'code': 'C1', 'description': 'desc'}],
        'materials': [{'type': 'MAIN', 'title': 't'}],
        'teaching_plans': [{'week': 1, 'topic': 't'}],
        'assessment_schemes': [
            {
                'name': 'Scheme1',
                'weight': 50,
                'components': [
                    {'name': 'Comp1', 'weight': 100, 'rubrics': [{'criteria': 'r', 'max_score': 10}]}
                ]
            }
        ]
    }

    result = svc.create_syllabus(payload.copy())
    # header created
    assert result.id == 123
    # child repos created
    assert len(clo_repo.items) == 1
    assert len(mat_repo.items) == 1
    assert len(plan_repo.items) == 1
    assert len(scheme_repo.items) == 1
    assert len(comp_repo.items) == 1
    assert len(rubric_repo.items) == 1

    # ensure time_allocation was serialized as JSON in the header create payload
    header_payload = repo.created[0]
    assert isinstance(header_payload['time_allocation'], str)
    parsed = json.loads(header_payload['time_allocation'])
    assert parsed['theory'] == 10


def test_submit_syllabus_allows_returned_case_insensitive():
    class GetRepo:
        def __init__(self, status):
            class Item:
                pass
            self.item = Item()
            self.item.status = status
        def get_by_id(self, id):
            return self.item
        def update(self, id, data):
            return data

    for status in ['returned', 'RETURNED', 'Returned']:
        repo = GetRepo(status)
        svc = SyllabusService(repository=repo)
        updated = svc.submit_syllabus(1, 2)
        assert updated == {'status': 'PENDING'}
</file>

<file path="utils/caching.py">
"""
Flask-Caching integration and cache utilities
"""
from flask_caching import Cache
from functools import wraps
from flask import request
import hashlib
import json

# Initialize cache (to be configured in create_app)
cache = Cache()


def cache_key_from_request():
    """
    Generate cache key from request parameters
    """
    args = request.args.to_dict()
    key_data = {
        'path': request.path,
        'args': args
    }
    key_string = json.dumps(key_data, sort_keys=True)
    return hashlib.md5(key_string.encode()).hexdigest()


def cached_response(timeout=300, key_prefix='view'):
    """
    Decorator to cache API responses
    
    Usage:
        @cached_response(timeout=600)
        def my_endpoint():
            pass
    
    Args:
        timeout: Cache timeout in seconds (default 5 minutes)
        key_prefix: Prefix for cache key
    """
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # Generate cache key
            cache_key = f"{key_prefix}:{request.path}:{cache_key_from_request()}"
            
            # Try to get from cache
            cached = cache.get(cache_key)
            if cached is not None:
                return cached
            
            # Execute function and cache result
            result = func(*args, **kwargs)
            cache.set(cache_key, result, timeout=timeout)
            
            return result
        return wrapper
    return decorator


def invalidate_cache(key_pattern):
    """
    Invalidate cache entries matching pattern
    
    Args:
        key_pattern: Pattern to match cache keys (e.g., 'syllabus:*')
    """
    try:
        cache.delete_memoized(key_pattern)
    except Exception:
        # Fallback: clear all cache if pattern delete not supported
        cache.clear()


def cache_model(model_name, model_id, timeout=600):
    """
    Decorator to cache model by ID
    
    Usage:
        @cache_model('syllabus', syllabus_id)
        def get_syllabus(id):
            pass
    """
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # Extract ID from kwargs or args
            entity_id = kwargs.get('id') or (args[0] if args else None)
            
            if entity_id:
                cache_key = f"model:{model_name}:{entity_id}"
                cached = cache.get(cache_key)
                if cached is not None:
                    return cached
            
            result = func(*args, **kwargs)
            
            if entity_id and result:
                cache_key = f"model:{model_name}:{entity_id}"
                cache.set(cache_key, result, timeout=timeout)
            
            return result
        return wrapper
    return decorator
</file>

<file path="utils/logging_config.py">
"""
Centralized logging configuration for the application
"""
import logging
import logging.handlers
import json
from datetime import datetime
from pathlib import Path
import os

class JSONFormatter(logging.Formatter):
    """
    Custom JSON formatter for structured logging
    """
    def format(self, record):
        log_data = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
            "module": record.module,
            "function": record.funcName,
            "line": record.lineno
        }
        
        # Add exception info if present
        if record.exc_info:
            log_data["exception"] = self.formatException(record.exc_info)
        
        # Add extra fields if present
        if hasattr(record, 'user_id'):
            log_data["user_id"] = record.user_id
        if hasattr(record, 'request_id'):
            log_data["request_id"] = record.request_id
        if hasattr(record, 'duration_ms'):
            log_data["duration_ms"] = record.duration_ms
        if hasattr(record, 'status_code'):
            log_data["status_code"] = record.status_code
            
        return json.dumps(log_data)


def setup_logging(app_name: str = "smd-api", log_level: str = "INFO", log_dir: str = "logs"):
    """
    Setup application logging with file rotation and structured format
    
    Args:
        app_name: Application name for logger
        log_level: Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL)
        log_dir: Directory to store log files
    """
    # Create logs directory if it doesn't exist
    log_path = Path(log_dir)
    log_path.mkdir(exist_ok=True)
    
    # Get root logger
    logger = logging.getLogger(app_name)
    logger.setLevel(getattr(logging, log_level.upper()))
    
    # Remove existing handlers to avoid duplicates
    logger.handlers.clear()
    
    # Console handler with simple format for development
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    console_format = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    console_handler.setFormatter(console_format)
    logger.addHandler(console_handler)
    
    # File handler with JSON format for production
    file_handler = logging.handlers.RotatingFileHandler(
        log_path / f"{app_name}.log",
        maxBytes=10*1024*1024,  # 10MB
        backupCount=5,
        encoding='utf-8'
    )
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(JSONFormatter())
    logger.addHandler(file_handler)
    
    # Separate error log file
    error_handler = logging.handlers.RotatingFileHandler(
        log_path / f"{app_name}_errors.log",
        maxBytes=10*1024*1024,  # 10MB
        backupCount=5,
        encoding='utf-8'
    )
    error_handler.setLevel(logging.ERROR)
    error_handler.setFormatter(JSONFormatter())
    logger.addHandler(error_handler)
    
    # Don't propagate to root logger
    logger.propagate = False
    
    return logger


def get_logger(name: str):
    """
    Get a logger instance with the application's root logger as parent
    
    Args:
        name: Logger name (typically __name__ of the module)
    
    Returns:
        Logger instance
    """
    return logging.getLogger(f"smd-api.{name}")
</file>

<file path="utils/pagination.py">
"""
Pagination utilities for list endpoints
"""
from typing import List, Dict, Any, Optional
from flask import request


class Pagination:
    """
    Pagination helper class
    """
    def __init__(self, items: List, page: int, page_size: int, total: int):
        self.items = items
        self.page = page
        self.page_size = page_size
        self.total = total
        self.pages = (total + page_size - 1) // page_size  # Ceiling division
    
    @property
    def has_prev(self) -> bool:
        return self.page > 1
    
    @property
    def has_next(self) -> bool:
        return self.page < self.pages
    
    @property
    def prev_page(self) -> Optional[int]:
        return self.page - 1 if self.has_prev else None
    
    @property
    def next_page(self) -> Optional[int]:
        return self.page + 1 if self.has_next else None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert pagination info to dictionary"""
        return {
            "data": self.items,  # Frontend expects 'data'
            "items": self.items,  # Keep for backward compatibility
            "total": self.total,  # Frontend expects 'total' at top level
            "total_pages": self.pages,  # Frontend expects 'total_pages' at top level
            "page": self.page,
            "page_size": self.page_size,
            "has_prev": self.has_prev,
            "has_next": self.has_next,
            "prev_page": self.prev_page,
            "next_page": self.next_page,
            "pagination": {  # Keep nested for backward compatibility
                "page": self.page,
                "page_size": self.page_size,
                "total_items": self.total,
                "total_pages": self.pages,
                "has_prev": self.has_prev,
                "has_next": self.has_next,
                "prev_page": self.prev_page,
                "next_page": self.next_page
            }
        }


def get_pagination_params(default_page_size: int = 20, max_page_size: int = 100) -> tuple:
    """
    Extract pagination parameters from request
    
    Args:
        default_page_size: Default number of items per page
        max_page_size: Maximum allowed page size
    
    Returns:
        Tuple of (page, page_size, offset)
    """
    page = request.args.get('page', 1, type=int)
    # Support both 'page_size' and 'limit' as aliases
    page_size = request.args.get('page_size', type=int) or request.args.get('limit', type=int) or default_page_size
    
    # Validate parameters
    page = max(1, page)  # Page must be at least 1
    page_size = min(max(1, page_size), max_page_size)  # Between 1 and max
    
    offset = (page - 1) * page_size
    
    return page, page_size, offset


def paginate(query, page: int, page_size: int, schema=None) -> Dict[str, Any]:
    """
    Paginate a SQLAlchemy query
    
    Args:
        query: SQLAlchemy query object
        page: Page number (1-indexed)
        page_size: Items per page
        schema: Optional Marshmallow schema for serialization
    
    Returns:
        Dictionary with items and pagination info
    """
    total = query.count()
    offset = (page - 1) * page_size
    items = query.offset(offset).limit(page_size).all()
    
    # Serialize if schema provided
    if schema:
        items = schema.dump(items, many=True)
    
    pagination = Pagination(items, page, page_size, total)
    return pagination.to_dict()
</file>

<file path="utils/performance.py">
"""
Performance monitoring decorator and utilities
"""
import time
import functools
from utils.logging_config import get_logger

logger = get_logger(__name__)


def monitor_performance(func):
    """
    Decorator to monitor function execution time and log performance metrics
    
    Usage:
        @monitor_performance
        def my_function():
            pass
    """
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        func_name = f"{func.__module__}.{func.__name__}"
        
        try:
            logger.debug(f"Starting {func_name}")
            result = func(*args, **kwargs)
            
            duration_ms = (time.time() - start_time) * 1000
            logger.info(
                f"Completed {func_name}",
                extra={"duration_ms": duration_ms, "status": "success"}
            )
            
            # Warn if execution takes too long
            if duration_ms > 1000:  # > 1 second
                logger.warning(
                    f"Slow execution detected: {func_name} took {duration_ms:.2f}ms"
                )
            
            return result
            
        except Exception as e:
            duration_ms = (time.time() - start_time) * 1000
            logger.error(
                f"Failed {func_name}: {str(e)}",
                extra={"duration_ms": duration_ms, "status": "error"},
                exc_info=True
            )
            raise
    
    return wrapper


def log_api_request(func):
    """
    Decorator to log API requests with details
    
    Usage:
        @log_api_request
        def my_endpoint():
            pass
    """
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        from flask import request, g
        
        start_time = time.time()
        endpoint = f"{request.method} {request.path}"
        
        # Get user_id from Flask g context if available
        user_id = getattr(g, 'user_id', None)
        
        logger.info(
            f"API Request: {endpoint}",
            extra={
                "method": request.method,
                "path": request.path,
                "user_id": user_id,
                "ip": request.remote_addr
            }
        )
        
        try:
            result = func(*args, **kwargs)
            duration_ms = (time.time() - start_time) * 1000
            
            # Extract status code from response
            status_code = 200
            if isinstance(result, tuple) and len(result) > 1:
                status_code = result[1]
            
            logger.info(
                f"API Response: {endpoint}",
                extra={
                    "duration_ms": duration_ms,
                    "status_code": status_code,
                    "user_id": user_id
                }
            )
            
            return result
            
        except Exception as e:
            duration_ms = (time.time() - start_time) * 1000
            logger.error(
                f"API Error: {endpoint} - {str(e)}",
                extra={
                    "duration_ms": duration_ms,
                    "status_code": 500,
                    "user_id": user_id
                },
                exc_info=True
            )
            raise
    
    return wrapper
</file>

<file path="verify_fixes.py">
"""
Verification Script - Test All Applied Fixes
Run this script to verify that all fixes have been applied correctly.

Usage:
    cd apps/api/src
    python verify_fixes.py
"""

import sys
import os

# Add src directory to path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

def test_imports():
    """Test 1: Verify all imports work."""
    print("\n=== Test 1: Imports ===")
    
    try:
        from dependency_container import Container
        print("✓ dependency_container imports successfully")
    except Exception as e:
        print(f"✗ dependency_container import failed: {e}")
        return False
    
    try:
        from infrastructure.databases.mssql import SessionLocal, engine
        print("✓ mssql imports successfully")
    except Exception as e:
        print(f"✗ mssql import failed: {e}")
        return False
    
    try:
        from domain.constants import WorkflowStatus
        print("✓ WorkflowStatus constants import successfully")
    except Exception as e:
        print(f"✗ WorkflowStatus import failed: {e}")
        return False
    
    try:
        from services.syllabus_service import SyllabusService
        print("✓ SyllabusService imports successfully")
    except Exception as e:
        print(f"✗ SyllabusService import failed: {e}")
        return False
    
    return True


def test_container_configuration():
    """Test 2: Verify DI Container configuration."""
    print("\n=== Test 2: DI Container Configuration ===")
    
    try:
        from dependency_container import Container
        container = Container()
        print("✓ Container created successfully")
        
        # Check if db_session is Factory (not Object)
        if hasattr(container, 'db_session'):
            provider = container.db_session
            provider_type = str(type(provider))
            if 'Factory' in provider_type:
                print("✓ db_session is Factory (correct)")
            else:
                print(f"✗ db_session is {provider_type} (should be Factory)")
                return False
        
        # Check if ai_service exists
        if hasattr(container, 'ai_service'):
            print("✓ ai_service provider exists")
        else:
            print("✗ ai_service provider not found")
            return False
        
        return True
        
    except Exception as e:
        print(f"✗ Container configuration test failed: {e}")
        return False


def test_session_isolation():
    """Test 3: Verify session isolation."""
    print("\n=== Test 3: Session Isolation ===")
    
    try:
        from infrastructure.databases.mssql import SessionLocal
        
        session1 = SessionLocal()
        session2 = SessionLocal()
        
        if session1 is not session2:
            print("✓ Sessions are isolated (different instances)")
            session1.close()
            session2.close()
            return True
        else:
            print("✗ Sessions are the same instance (should be different)")
            return False
            
    except Exception as e:
        print(f"✗ Session isolation test failed: {e}")
        return False


def test_workflow_constants():
    """Test 4: Verify workflow constants."""
    print("\n=== Test 4: Workflow Constants ===")
    
    try:
        from domain.constants import WorkflowStatus
        
        # Check all required states exist
        required_states = ['DRAFT', 'PENDING', 'APPROVED', 'REJECTED']
        for state in required_states:
            if hasattr(WorkflowStatus, state):
                print(f"✓ WorkflowStatus.{state} exists")
            else:
                print(f"✗ WorkflowStatus.{state} missing")
                return False
        
        # Check valid state tuples
        if hasattr(WorkflowStatus, 'VALID_FOR_SUBMISSION'):
            valid = WorkflowStatus.VALID_FOR_SUBMISSION
            if 'DRAFT' in valid and 'REJECTED' in valid:
                print(f"✓ VALID_FOR_SUBMISSION correct: {valid}")
            else:
                print(f"✗ VALID_FOR_SUBMISSION incorrect: {valid}")
                return False
        else:
            print("✗ VALID_FOR_SUBMISSION not defined")
            return False
        
        return True
        
    except Exception as e:
        print(f"✗ Workflow constants test failed: {e}")
        return False


def test_service_logic():
    """Test 5: Verify SyllabusService logic improvements."""
    print("\n=== Test 5: SyllabusService Logic ===")
    
    try:
        from services.syllabus_service import SyllabusService
        import inspect
        
        # Check submit_syllabus method signature and docstring
        if hasattr(SyllabusService, 'submit_syllabus'):
            method = getattr(SyllabusService, 'submit_syllabus')
            docstring = inspect.getdoc(method)
            
            if docstring and 'DRAFT or REJECTED' in docstring:
                print("✓ submit_syllabus has updated docstring")
            else:
                print("⚠ submit_syllabus docstring might need update")
            
            # Check source code for 'RETURNED'
            source = inspect.getsource(method)
            if 'RETURNED' in source:
                print("✗ submit_syllabus still contains 'RETURNED' reference")
                return False
            else:
                print("✓ submit_syllabus no longer references 'RETURNED'")
        else:
            print("✗ submit_syllabus method not found")
            return False
        
        # Check evaluate_syllabus method
        if hasattr(SyllabusService, 'evaluate_syllabus'):
            method = getattr(SyllabusService, 'evaluate_syllabus')
            source = inspect.getsource(method)
            
            if 'PENDING' in source:
                print("✓ evaluate_syllabus checks for PENDING status")
            else:
                print("⚠ evaluate_syllabus might not check status")
        
        return True
        
    except Exception as e:
        print(f"✗ Service logic test failed: {e}")
        return False


def test_controller_decorators():
    """Test 6: Verify @token_required decorators."""
    print("\n=== Test 6: Controller Decorators ===")
    
    try:
        from api.controllers.syllabus_controller import submit_syllabus, evaluate_syllabus
        import inspect
        
        # Check submit_syllabus for @token_required
        source = inspect.getsource(submit_syllabus)
        if '@token_required' in source:
            print("✓ submit_syllabus has @token_required decorator")
        else:
            print("✗ submit_syllabus missing @token_required decorator")
            return False
        
        # Check evaluate_syllabus for @token_required
        source = inspect.getsource(evaluate_syllabus)
        if '@token_required' in source:
            print("✓ evaluate_syllabus has @token_required decorator")
        else:
            print("✗ evaluate_syllabus missing @token_required decorator")
            return False
        
        return True
        
    except Exception as e:
        print(f"✗ Controller decorators test failed: {e}")
        return False


def test_database_config():
    """Test 7: Verify database configuration."""
    print("\n=== Test 7: Database Configuration ===")
    
    try:
        from infrastructure.databases.mssql import engine
        
        # Check pool configuration
        pool = engine.pool
        pool_class = str(type(pool))
        
        if 'QueuePool' in pool_class:
            print(f"✓ Using QueuePool: {pool_class}")
        else:
            print(f"⚠ Not using QueuePool: {pool_class}")
        
        # Check pool size
        if hasattr(pool, '_pool'):
            print(f"✓ Pool configured with size: {pool.size()}")
        
        return True
        
    except Exception as e:
        print(f"✗ Database config test failed: {e}")
        return False


def test_error_handling():
    """Test 8: Verify error handling improvements."""
    print("\n=== Test 8: Error Handling ===")
    
    try:
        from api.controllers.ai_controller import generate
        import inspect
        
        source = inspect.getsource(generate)
        
        # Check for try-except blocks
        if 'try:' in source and 'except' in source:
            print("✓ AI controller has try-except blocks")
        else:
            print("✗ AI controller missing error handling")
            return False
        
        # Check for logging
        if 'logger' in source or 'logging' in source:
            print("✓ AI controller has logging")
        else:
            print("⚠ AI controller might not have logging")
        
        # Check for input validation
        if 'strip()' in source:
            print("✓ AI controller validates input")
        else:
            print("⚠ AI controller might not validate input")
        
        return True
        
    except Exception as e:
        print(f"✗ Error handling test failed: {e}")
        return False


def main():
    """Run all verification tests."""
    print("=" * 60)
    print("VERIFICATION SCRIPT - Testing All Applied Fixes")
    print("=" * 60)
    
    tests = [
        ("Imports", test_imports),
        ("Container Configuration", test_container_configuration),
        ("Session Isolation", test_session_isolation),
        ("Workflow Constants", test_workflow_constants),
        ("Service Logic", test_service_logic),
        ("Controller Decorators", test_controller_decorators),
        ("Database Configuration", test_database_config),
        ("Error Handling", test_error_handling),
    ]
    
    results = []
    for name, test_func in tests:
        try:
            result = test_func()
            results.append((name, result))
        except Exception as e:
            print(f"\n✗ Test '{name}' crashed: {e}")
            results.append((name, False))
    
    # Summary
    print("\n" + "=" * 60)
    print("SUMMARY")
    print("=" * 60)
    
    passed = sum(1 for _, result in results if result)
    total = len(results)
    
    for name, result in results:
        status = "✓ PASS" if result else "✗ FAIL"
        print(f"{status}: {name}")
    
    print(f"\nTotal: {passed}/{total} tests passed")
    
    if passed == total:
        print("\n🎉 ALL TESTS PASSED! Fixes verified successfully.")
        return 0
    else:
        print(f"\n⚠️ {total - passed} test(s) failed. Please review the output above.")
        return 1


if __name__ == "__main__":
    sys.exit(main())
</file>

</files>
